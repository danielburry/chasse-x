"use strict";var V=Object.defineProperty,w=Object.getOwnPropertySymbols,z=Object.prototype.hasOwnProperty,W=Object.prototype.propertyIsEnumerable,v=(C,P,l)=>P in C?V(C,P,{enumerable:!0,configurable:!0,writable:!0,value:l}):C[P]=l,H=(C,P)=>{for(var l in P||(P={}))z.call(P,l)&&v(C,l,P[l]);if(w)for(var l of w(P))W.call(P,l)&&v(C,l,P[l]);return C};(self.webpackChunkchasse_pwa_front=self.webpackChunkchasse_pwa_front||[]).push([[5314],{83994:(C,P,l)=>{l.d(P,{f:()=>o});var M=l(15861),B=l(85931),i=l(63290),S=l(62208),b=l(55713),N=l(81653),e=l(57596),n=l(67969);const u=i.Z.getLogger("esri.views.webgl.BufferObject");class o{constructor(r,a,E,h){this._context=r,this.bufferType=a,this.usage=E,this._glName=null,this._size=-1,this._indexType=void 0,r.instanceCounter.increment(n._g.BufferObject,this),this._glName=this._context.gl.createBuffer(),(0,N.zu)(this._context.gl),h&&this.setData(h)}static createIndex(r,a,E){return new o(r,n.w0.ELEMENT_ARRAY_BUFFER,a,E)}static createVertex(r,a,E){return new o(r,n.w0.ARRAY_BUFFER,a,E)}static createUniform(r,a,E){if(r.type!==e.zO.WEBGL2)throw new Error("Uniform buffers are supported in WebGL2 only!");return new o(r,n.w0.UNIFORM_BUFFER,a,E)}static createPixelPack(r,a=n.l1.STREAM_READ,E){if(r.type!==e.zO.WEBGL2)throw new Error("Pixel pack buffers are supported in WebGL2 only!");const h=new o(r,n.w0.PIXEL_PACK_BUFFER,a);return E&&h.setSize(E),h}static createPixelUnpack(r,a=n.l1.STREAM_DRAW,E){if(r.type!==e.zO.WEBGL2)throw new Error("Pixel unpack buffers are supported in WebGL2 only!");return new o(r,n.w0.PIXEL_UNPACK_BUFFER,a,E)}get glName(){return this._glName}get size(){return this._size}get indexType(){return this._indexType}get byteSize(){return this.bufferType===n.w0.ELEMENT_ARRAY_BUFFER?this._indexType===n.g.UNSIGNED_INT?4*this._size:2*this._size:this._size}get _isVAOAware(){return this.bufferType===n.w0.ELEMENT_ARRAY_BUFFER||this.bufferType===n.w0.ARRAY_BUFFER}dispose(){var r;(null==(r=this._context)?void 0:r.gl)?(this._glName&&(this._context.gl.deleteBuffer(this._glName),this._glName=null),this._context.instanceCounter.decrement(n._g.BufferObject,this),this._context=null):this._glName&&u.warn("Leaked WebGL buffer object")}setSize(r,a=null){if(r<=0&&u.error("Buffer size needs to be positive!"),this.bufferType===n.w0.ELEMENT_ARRAY_BUFFER&&(0,S.pC)(a))switch(this._indexType=a,a){case n.g.UNSIGNED_SHORT:r*=2;break;case n.g.UNSIGNED_INT:r*=4}this._setBufferData(r)}setData(r){if(!r)return;let a=r.byteLength;this.bufferType===n.w0.ELEMENT_ARRAY_BUFFER&&((0,b.Uc)(r)&&(a/=2,this._indexType=n.g.UNSIGNED_SHORT),(0,b.ZY)(r)&&(a/=4,this._indexType=n.g.UNSIGNED_INT)),this._setBufferData(a,r)}_setBufferData(r,a=null){this._size=r;const E=this._context.getBoundVAO();this._isVAOAware&&this._context.bindVAO(null),this._context.bindBuffer(this);const h=this._context.gl;(0,S.pC)(a)?h.bufferData(this.bufferType,a,this.usage):h.bufferData(this.bufferType,r,this.usage),(0,N.zu)(h),this._isVAOAware&&this._context.bindVAO(E)}setSubData(r,a=0,E=0,h=r.byteLength){if(!r)return;(a<0||a>=this._size)&&u.error("offset is out of range!");let T=a,c=E,m=h,A=r.byteLength;this.bufferType===n.w0.ELEMENT_ARRAY_BUFFER&&((0,b.Uc)(r)?(A/=2,T*=2,c*=2,m*=2):(0,b.ZY)(r)&&(A/=4,T*=4,c*=4,m*=4)),void 0===h&&(h=A-1),E>=h&&u.error("end must be bigger than start!"),a+E-h>this._size&&u.error("An attempt to write beyond the end of the buffer!");const t=this._context.getBoundVAO();this._isVAOAware&&this._context.bindVAO(null),this._context.bindBuffer(this);const s=this._context.gl,_=ArrayBuffer.isView(r)?r.buffer:r,f=0===c&&m===r.byteLength?_:_.slice(c,m);s.bufferSubData(this.bufferType,T,f),(0,N.zu)(s),this._isVAOAware&&this._context.bindVAO(t)}setSubDataFromView(r,a,E,h){if(!r)return;(a<0||a>=this._size)&&u.error("offset is out of range!"),E>=h&&u.error("end must be bigger than start!"),a+E-h>this._size&&u.error("An attempt to write beyond the end of the buffer!");const T=this._context.getBoundVAO();this._isVAOAware&&this._context.bindVAO(null),this._context.bindBuffer(this);const c=this._context.gl;if(this._context.type===e.zO.WEBGL2)c.bufferSubData(this.bufferType,a*r.BYTES_PER_ELEMENT,r,E,h-E);else{const m=0===E&&h===r.length?r:r.subarray(E,h);c.bufferSubData(this.bufferType,a*r.BYTES_PER_ELEMENT,m)}(0,N.zu)(c),this._isVAOAware&&this._context.bindVAO(T)}getSubData(r,a=0,E,h){if(this._context.type!==e.zO.WEBGL2)return void u.error("Get buffer subdata is supported in WebGL2 only!");if(E<0||h<0)return void u.error("Problem getting subdata: offset and length were less than zero!");const T=function x(d){return(0,B.zG)(d)}(r)?r.BYTES_PER_ELEMENT:1;if(T*((null!=E?E:0)+(null!=h?h:0))>r.byteLength)return void u.error("Problem getting subdata: offset and length exceeded destination size!");a+T*(null!=h?h:0)>this.byteSize&&u.warn("Potential problem getting subdata: requested data exceeds buffer size!");const c=this._context.gl;this._context.bindBuffer(this,n.w0.COPY_READ_BUFFER),c.getBufferSubData(n.w0.COPY_READ_BUFFER,a,r,E,h),this._context.unbindBuffer(n.w0.COPY_READ_BUFFER)}getSubDataAsync(r,a=0,E,h){var T=this;return(0,M.Z)(function*(){T._context.type===e.zO.WEBGL2?(yield T._context.clientWaitAsync(),T.getSubData(r,a,E,h)):u.error("Get buffer subdata is supported in WebGL2 only!")})()}}},85775:(C,P,l)=>{l.d(P,{X:()=>d});var M=l(15861),B=l(63290),i=l(62208),S=l(83994),b=l(81653),N=l(57596),e=l(67969),n=l(49266),u=l(55086),x=l(26906);const o=B.Z.getLogger("esri.views.webgl.FrameBufferObject");class d{constructor(t,s,_=null,f=null){var D;if(this._context=t,this._glName=null,this._depthAttachment=null,this._stencilAttachment=null,this._colorAttachments=new Map,this._initialized=!1,this._desc=H({},s),t.instanceCounter.increment(e._g.FramebufferObject,this),(0,i.pC)(_)){Array.isArray(_)||(_=[_]);for(let p=0;p<_.length;++p){const R=_[p],g=e.VY.COLOR_ATTACHMENT0+p;let O;E(R)?(r(R)?(O=R.descriptor,this._colorAttachments.set(g,R)):(O=R,this._colorAttachments.set(g,new u.x(this._context,O))),T(O,this._desc)):(a(R)?(O=R.descriptor,this._colorAttachments.set(g,R)):(O=R,this._colorAttachments.set(g,new n.r(this._context,O))),c(O,this._desc)),this._validateColorAttachmentPoint(g)}}if((0,i.pC)(f)){let p,R;if(E(f))this._context.capabilities.depthTexture||console.error("Setting the depth/stencil texture as an attachment requires WEBGL_depth_texture or WebGL2"),r(f)?(R=f.descriptor,this._depthStencilTexture=f):(R=f,this._depthStencilTexture=new u.x(this._context,R)),T(R,this._desc);else{a(f)?(R=f.descriptor,p=f):(R=f,p=new n.r(this._context,R));const g=null!=(D=this._desc.depthStencilTarget)?D:e.OU.DEPTH_STENCIL_RENDER_BUFFER;g===e.OU.STENCIL_RENDER_BUFFER?this._stencilAttachment=p:g===e.OU.DEPTH_RENDER_BUFFER||g===e.OU.DEPTH_STENCIL_RENDER_BUFFER?this._depthAttachment=p:console.error('If a Renderbuffer is provided, "depthStencilTarget" must be one of STENCIL_RENDER_BUFFER, DEPTH_RENDER_BUFFER or DEPTH_STENCIL_RENDER_BUFFER'),c(R,this._desc)}}}dispose(){if(!this._desc)return;const t=this._context.getBoundFramebufferObject();this._disposeColorAttachments(),this._disposeDepthStencilAttachments(),this._glName&&(this._context.gl.deleteFramebuffer(this._glName),this._glName=null),this._context.bindFramebuffer(t),this._context.instanceCounter.decrement(e._g.FramebufferObject,this),this._desc=null}get glName(){return this._glName}get descriptor(){return this._desc}get colorTexture(){const t=this._colorAttachments.get(e.VY.COLOR_ATTACHMENT0);return t&&r(t)?t:null}get colorAttachment(){return this._colorAttachments.get(e.VY.COLOR_ATTACHMENT0)}get depthStencilAttachment(){return this._depthStencilTexture||this._depthAttachment||this._stencilAttachment}get depthStencilTexture(){return this._depthStencilTexture}get width(){return this._desc.width}get height(){return this._desc.height}get gpuMemoryUsage(){return[...this._colorAttachments].reduce((t,[s,_])=>t+(0,x.un)(_),0)+(0,x.un)(this.depthStencilAttachment)}getColorTexture(t){const s=this._colorAttachments.get(t);return s&&r(s)?s:null}attachColorTexture(t,s=e.VY.COLOR_ATTACHMENT0){!t||(this._validateColorAttachmentPoint(s),T(t.descriptor,this._desc),this._disposeColorAttachments(),this._initialized&&(this._context.bindFramebuffer(this),this._framebufferTexture2D(t.glName,s)),this._colorAttachments.set(s,t))}detachColorTexture(t=e.VY.COLOR_ATTACHMENT0){const s=this._colorAttachments.get(t);if(r(s)){const _=s;return this._initialized&&(this._context.bindFramebuffer(this),this._framebufferTexture2D(null,t)),this._colorAttachments.delete(t),_}}setColorTextureTarget(t,s=e.VY.COLOR_ATTACHMENT0){const _=this._colorAttachments.get(s);r(_)&&this._framebufferTexture2D(_.glName,s,t)}attachDepthStencilTexture(t){if((0,i.Wi)(t))return;const s=t.descriptor;s.pixelFormat!==e.VI.DEPTH_STENCIL&&console.error("Depth/Stencil texture must have a pixel type of DEPTH_STENCIL!"),s.dataType!==e.Br.UNSIGNED_INT_24_8&&console.error("Depth/Stencil texture must have data type of UNSIGNED_INT_24_8!"),this._context.capabilities.depthTexture||console.error("Extension WEBGL_depth_texture isn't supported therefore it is no possible to set the depth/stencil texture!"),T(s,this._desc),this._desc.depthStencilTarget&&this._desc.depthStencilTarget!==e.OU.DEPTH_STENCIL_TEXTURE&&(this._desc.depthStencilTarget=e.OU.DEPTH_STENCIL_TEXTURE),this._disposeDepthStencilAttachments(),this._initialized&&(this._context.bindFramebuffer(this),this._framebufferTexture2D(t.glName,e.Lu)),this._depthStencilTexture=t}detachDepthStencilTexture(){const t=this._depthStencilTexture;return t&&this._initialized&&(this._context.bindFramebuffer(this),this._framebufferTexture2D(null,e.Lu)),this._depthStencilTexture=null,t}attachDepthStencilBuffer(t){if((0,i.Wi)(t))return;const s=t.descriptor;if(s.internalFormat!==e.Tg.DEPTH_STENCIL&&s.internalFormat!==e.Tg.DEPTH_COMPONENT16&&console.error("Depth/Stencil buffer must have correct internalFormat"),c(s,this._desc),this._disposeDepthStencilAttachments(),this._desc.depthStencilTarget=s.internalFormat===e.Tg.DEPTH_STENCIL?e.OU.DEPTH_STENCIL_RENDER_BUFFER:e.OU.DEPTH_RENDER_BUFFER,this._initialized){this._context.bindFramebuffer(this);const _=this._context.gl;_.framebufferRenderbuffer(e.qi.FRAMEBUFFER,this._desc.depthStencilTarget===e.OU.DEPTH_RENDER_BUFFER?_.DEPTH_ATTACHMENT:_.DEPTH_STENCIL_ATTACHMENT,_.RENDERBUFFER,t.glName)}this._depthAttachment=t}detachDepthStencilBuffer(){const t=this._context.gl,s=this._depthAttachment;return s&&this._initialized&&(this._context.bindFramebuffer(this),t.framebufferRenderbuffer(e.qi.FRAMEBUFFER,this._desc.depthStencilTarget===e.OU.DEPTH_RENDER_BUFFER?t.DEPTH_ATTACHMENT:t.DEPTH_STENCIL_ATTACHMENT,t.RENDERBUFFER,null)),this._depthAttachment=null,s}detachAll(){this._colorAttachments.forEach((t,s)=>this._detachColorAttachment(s)),this.detachDepthStencilBuffer(),this.detachDepthStencilTexture()}copyToTexture(t,s,_,f,D,p,R){(t<0||s<0||D<0||p<0)&&console.error("Offsets cannot be negative!"),(_<=0||f<=0)&&console.error("Copy width and height must be greater than zero!");const g=this._desc,O=R.descriptor;R.descriptor.target!==e.No.TEXTURE_2D&&console.error("Texture target must be TEXTURE_2D!"),(t+_>g.width||s+f>g.height||D+_>O.width||p+f>O.height)&&console.error("Bad dimensions, the current input values will attempt to read or copy out of bounds!");const F=this._context,L=F.bindTexture(R,u.x.TEXTURE_UNIT_FOR_UPDATES);F.setActiveTexture(u.x.TEXTURE_UNIT_FOR_UPDATES),F.bindFramebuffer(this),F.gl.copyTexSubImage2D(e.No.TEXTURE_2D,0,D,p,t,s,_,f),F.bindTexture(L,u.x.TEXTURE_UNIT_FOR_UPDATES)}readPixels(t,s,_,f,D,p,R){(_<=0||f<=0)&&console.error("Copy width and height must be greater than zero!"),R||console.error("Target memory is not initialized!"),this._context.bindFramebuffer(this),this._context.gl.readPixels(t,s,_,f,D,p,R)}readPixelsAsync(t,s,_,f,D,p,R){var g=this;return(0,M.Z)(function*(){if(g._context.type!==N.zO.WEBGL2)return(0,b.hZ)()&&console.warn("Attempting to read pixels using pixel buffer object without WebGL2"),void g.readPixels(t,s,_,f,D,p,R);const O=g._context.gl,F=S.f.createPixelPack(g._context,e.l1.STREAM_READ,R.byteLength);g._context.bindBuffer(F),g._context.bindFramebuffer(g),O.readPixels(t,s,_,f,D,p,0),g._context.unbindBuffer(e.w0.PIXEL_PACK_BUFFER),yield F.getSubDataAsync(R),F.dispose()})()}resize(t,s){const _=this._desc;if(_.width!==t||_.height!==s){if(!this._initialized)return _.width=t,_.height=s,this._colorAttachments.forEach(f=>{f&&f.resize(t,s)}),void(this._depthStencilTexture&&this._depthStencilTexture.resize(t,s));_.width=t,_.height=s,this._colorAttachments.forEach(f=>{f&&f.resize(t,s)}),null!=this._depthStencilTexture?this._depthStencilTexture.resize(t,s):(this._depthAttachment||this._stencilAttachment)&&(this._depthAttachment&&this._depthAttachment.resize(t,s),this._stencilAttachment&&this._stencilAttachment.resize(t,s)),this._context.getBoundFramebufferObject()===this&&this._context.bindFramebuffer(null),this._initialized=!1}}initializeAndBind(t=e.qi.FRAMEBUFFER){var F,L,I,y;const s=this._context.gl;if(this._initialized)return void s.bindFramebuffer(t,this.glName);this._glName&&s.deleteFramebuffer(this._glName);const _=this._context,f=s.createFramebuffer(),D=this._desc,p=null!=(F=D.colorTarget)?F:e.Lm.RENDER_BUFFER,R=null!=(L=D.width)?L:1,g=null!=(I=D.height)?I:1;if(s.bindFramebuffer(t,f),0===this._colorAttachments.size)if(p===e.Lm.TEXTURE||p===e.Lm.CUBEMAP)this._colorAttachments.set(e.VY.COLOR_ATTACHMENT0,function h(A,t,s){return new u.x(A,{target:s,pixelFormat:e.VI.RGBA,dataType:e.Br.UNSIGNED_BYTE,samplingMode:e.cw.NEAREST,wrapMode:e.e8.CLAMP_TO_EDGE,width:t.width,height:t.height})}(_,D,this.descriptor.colorTarget===e.Lm.CUBEMAP?e.No.TEXTURE_CUBE_MAP:e.No.TEXTURE_2D));else{const U=new n.r(_,{internalFormat:e.lP.RGBA4,width:R,height:g});this._colorAttachments.set(e.VY.COLOR_ATTACHMENT0,U)}this._colorAttachments.forEach((U,G)=>{U&&(r(U)?this._framebufferTexture2D(U.glName,G,m(U),t):s.framebufferRenderbuffer(t,G,s.RENDERBUFFER,U.glName))});const O=null!=(y=D.depthStencilTarget)?y:e.OU.NONE;switch(O){case e.OU.DEPTH_RENDER_BUFFER:case e.OU.DEPTH_STENCIL_RENDER_BUFFER:this._depthAttachment||(this._depthAttachment=new n.r(_,{internalFormat:D.depthStencilTarget===e.OU.DEPTH_RENDER_BUFFER?e.Tg.DEPTH_COMPONENT16:e.Tg.DEPTH_STENCIL,width:R,height:g})),s.framebufferRenderbuffer(t,O===e.OU.DEPTH_RENDER_BUFFER?s.DEPTH_ATTACHMENT:s.DEPTH_STENCIL_ATTACHMENT,s.RENDERBUFFER,this._depthAttachment.glName);break;case e.OU.STENCIL_RENDER_BUFFER:this._stencilAttachment||(this._stencilAttachment=new n.r(_,{internalFormat:e.Tg.STENCIL_INDEX8,width:R,height:g})),s.framebufferRenderbuffer(t,s.STENCIL_ATTACHMENT,s.RENDERBUFFER,this._stencilAttachment.glName);break;case e.OU.DEPTH_STENCIL_TEXTURE:this._depthStencilTexture||(_.capabilities.depthTexture||console.error("Extension WEBGL_depth_texture isn't supported therefore it is no possible to set the depth/stencil texture as an attachment!"),this._depthStencilTexture=new u.x(_,{target:e.No.TEXTURE_2D,pixelFormat:e.VI.DEPTH_STENCIL,dataType:e.Br.UNSIGNED_INT_24_8,samplingMode:e.cw.NEAREST,wrapMode:e.e8.CLAMP_TO_EDGE,width:R,height:g})),this._framebufferTexture2D(this._depthStencilTexture.glName,s.DEPTH_STENCIL_ATTACHMENT,m(this._depthStencilTexture),t)}(0,b.CG)()&&s.checkFramebufferStatus(t)!==s.FRAMEBUFFER_COMPLETE&&console.error("Framebuffer is incomplete!"),this._glName=f,this._initialized=!0}_framebufferTexture2D(t,s=e.VY.COLOR_ATTACHMENT0,_=e.No.TEXTURE_2D,f=e.qi.FRAMEBUFFER,D=0){this._context.gl.framebufferTexture2D(f,s,_,t,D)}_detachColorAttachment(t){(0,b.hZ)()&&console.warn("Detaching an FBO attachment can be a slow due to invalidating framebuffer completeness!");const s=this._context.gl,_=this._colorAttachments.get(t);return r(_)?this._initialized&&(this._context.bindFramebuffer(this),this._framebufferTexture2D(null,t)):this._initialized&&(this._context.bindFramebuffer(this),s.framebufferRenderbuffer(e.qi.FRAMEBUFFER,t,s.RENDERBUFFER,null)),this._colorAttachments.delete(t),_}_disposeColorAttachments(){this._colorAttachments.forEach((t,s)=>{this._detachColorAttachment(s),t.dispose()}),this._colorAttachments.clear()}_disposeDepthStencilAttachments(){const t=this._context.gl;this._depthAttachment&&(this._initialized&&(this._context.bindFramebuffer(this),t.framebufferRenderbuffer(e.qi.FRAMEBUFFER,this._desc.depthStencilTarget===e.OU.DEPTH_RENDER_BUFFER?t.DEPTH_ATTACHMENT:t.DEPTH_STENCIL_ATTACHMENT,t.RENDERBUFFER,null)),this._depthAttachment.dispose(),this._depthAttachment=null),this._stencilAttachment&&(this._initialized&&(this._context.bindFramebuffer(this),t.framebufferRenderbuffer(e.qi.FRAMEBUFFER,t.STENCIL_ATTACHMENT,t.RENDERBUFFER,null)),this._stencilAttachment.dispose(),this._stencilAttachment=null),this._depthStencilTexture&&(this._initialized&&(this._context.bindFramebuffer(this),this._framebufferTexture2D(null,t.DEPTH_STENCIL_ATTACHMENT)),this._depthStencilTexture.dispose(),this._depthStencilTexture=null)}_validateColorAttachmentPoint(t){if(-1===d._MAX_COLOR_ATTACHMENTS){const _=this._context.capabilities.drawBuffers;d._MAX_COLOR_ATTACHMENTS=_?this._context.gl.getParameter(_.MAX_COLOR_ATTACHMENTS):1}const s=t-e.VY.COLOR_ATTACHMENT0;s+1>d._MAX_COLOR_ATTACHMENTS&&o.error("esri.FrameBufferObject",`illegal attachment point for color attachment: ${s+1}. Implementation supports up to ${d._MAX_COLOR_ATTACHMENTS} color attachments`)}}function r(A){return"type"in A&&"texture"===A.type}function a(A){return"type"in A&&"renderbuffer"===A.type}function E(A){return r(A)||"pixelFormat"in A}function T(A,t){A.target!==e.No.TEXTURE_2D&&A.target!==e.No.TEXTURE_CUBE_MAP&&console.error("Texture type must be TEXTURE_2D or TEXTURE_CUBE_MAP!"),void 0!==t.width&&t.width>=0&&void 0!==t.height&&t.height>=0?t.width===A.width&&t.height===A.height||console.error("Color attachment texture must match the framebuffer's!"):(t.width=A.width,t.height=A.height)}function c(A,t){void 0!==t.width&&t.width>=0&&void 0!==t.height&&t.height>=0?t.width===A.width&&t.height===A.height||console.error("Renderbuffer dimensions must match the framebuffer's!"):(t.width=A.width,t.height=A.height)}function m(A){return A.descriptor.target===e.No.TEXTURE_CUBE_MAP?e.No.TEXTURE_CUBE_MAP_POSITIVE_X:e.No.TEXTURE_2D}d._MAX_COLOR_ATTACHMENTS=-1},49266:(C,P,l)=>{l.d(P,{r:()=>i});var M=l(57596),B=l(67969);class i{constructor(b,N){this._context=b,this._desc=N,this.type="renderbuffer",this._context.instanceCounter.increment(B._g.Renderbuffer,this);const e=this._context.gl;this.glName=e.createRenderbuffer(),this._context.bindRenderbuffer(this);const{width:n,height:u,internalFormat:x,multisampled:o}=N;if(o){if(this._context.type!==M.zO.WEBGL2)throw new Error("Multisampled renderbuffers are not supported in WebGL1!");e.renderbufferStorageMultisample(e.RENDERBUFFER,this.samples,x,n,u)}else e.renderbufferStorage(e.RENDERBUFFER,x,n,u)}get descriptor(){return this._desc}get samples(){const b=this._desc.samples,N=this._context.parameters.maxSamples;return b?Math.min(b,N):N}resize(b,N){const e=this._desc;if(e.width===b&&e.height===N)return;e.width=b,e.height=N;const n=this._context.gl;this._context.bindRenderbuffer(this),e.multisampled?n.renderbufferStorageMultisample(n.RENDERBUFFER,this.samples,e.internalFormat,e.width,e.height):n.renderbufferStorage(n.RENDERBUFFER,e.internalFormat,e.width,e.height)}dispose(){this._context&&(this._context.gl.deleteRenderbuffer(this.glName),this._context.instanceCounter.decrement(B._g.Renderbuffer,this),this._context=null)}}},26906:(C,P,l)=>{l.d(P,{HH:()=>S,RG:()=>u,UF:()=>n,XP:()=>e,_V:()=>b,un:()=>x}),l(8314);var B=l(62208),i=l(67969);function S(o){const d=o.gl;switch(d.getError()){case d.NO_ERROR:return null;case d.INVALID_ENUM:return"An unacceptable value has been specified for an enumerated argument";case d.INVALID_VALUE:return"A numeric argument is out of range";case d.INVALID_OPERATION:return"The specified command is not allowed for the current state";case d.INVALID_FRAMEBUFFER_OPERATION:return"The currently bound framebuffer is not framebuffer complete";case d.OUT_OF_MEMORY:return"Not enough memory is left to execute the command";case d.CONTEXT_LOST_WEBGL:return"WebGL context is lost"}return"Unknown error"}function b(o,d){return o.vertexBuffers[d].size/function N(o){return o[0].stride}(o.layout[d])}function e(o,d,r,a,E=0){const h=o.gl,T=o.capabilities.instancing;o.bindBuffer(r);for(const c of a){const m=d.get(c.name);void 0===m&&console.error(`There is no location for vertex attribute '${c.name}' defined.`);const A=E*c.stride;if(c.count<=4)h.vertexAttribPointer(m,c.count,c.type,c.normalized,c.stride,c.offset+A),h.enableVertexAttribArray(m),c.divisor>0&&T&&T.vertexAttribDivisor(m,c.divisor);else if(9===c.count)for(let t=0;t<3;t++)h.vertexAttribPointer(m+t,3,c.type,c.normalized,c.stride,c.offset+12*t+A),h.enableVertexAttribArray(m+t),c.divisor>0&&T&&T.vertexAttribDivisor(m+t,c.divisor);else if(16===c.count)for(let t=0;t<4;t++)h.vertexAttribPointer(m+t,4,c.type,c.normalized,c.stride,c.offset+16*t+A),h.enableVertexAttribArray(m+t),c.divisor>0&&T&&T.vertexAttribDivisor(m+t,c.divisor);else console.error("Unsupported vertex attribute element count: "+c.count)}}function n(o,d,r,a){const E=o.gl,h=o.capabilities.instancing;o.bindBuffer(r);for(const T of a){const c=d.get(T.name);if(T.count<=4)E.disableVertexAttribArray(c),T.divisor&&T.divisor>0&&h&&h.vertexAttribDivisor(c,0);else if(9===T.count)for(let m=0;m<3;m++)E.disableVertexAttribArray(c+m),T.divisor&&T.divisor>0&&h&&h.vertexAttribDivisor(c+m,0);else if(16===T.count)for(let m=0;m<4;m++)E.disableVertexAttribArray(c+m),T.divisor&&T.divisor>0&&h&&h.vertexAttribDivisor(c+m,0);else console.error("Unsupported vertex attribute element count: "+T.count)}o.unbindBuffer(i.w0.ARRAY_BUFFER)}function u(o){switch(o){case i.VI.ALPHA:case i.VI.LUMINANCE:case i.VI.RED:case i.VI.RED_INTEGER:case i.lP.R8:case i.lP.R8I:case i.lP.R8UI:case i.lP.R8_SNORM:case i.Tg.STENCIL_INDEX8:return 1;case i.VI.LUMINANCE_ALPHA:case i.VI.RG:case i.VI.RG_INTEGER:case i.lP.RGBA4:case i.lP.R16F:case i.lP.R16I:case i.lP.R16UI:case i.lP.RG8:case i.lP.RG8I:case i.lP.RG8UI:case i.lP.RG8_SNORM:case i.lP.RGB565:case i.lP.RGB5_A1:case i.Tg.DEPTH_COMPONENT16:return 2;case i.VI.DEPTH_COMPONENT:case i.VI.RGB:case i.VI.RGB_INTEGER:case i.lP.RGB8:case i.lP.RGB8I:case i.lP.RGB8UI:case i.lP.RGB8_SNORM:case i.lP.SRGB8:case i.Tg.DEPTH_COMPONENT24:return 3;case i.VI.DEPTH_STENCIL:case i.VI.RGBA:case i.VI.RGBA_INTEGER:case i.lP.RGBA8:case i.lP.R32F:case i.lP.R11F_G11F_B10F:case i.lP.RG16F:case i.lP.R32I:case i.lP.R32UI:case i.lP.RG16I:case i.lP.RG16UI:case i.lP.RGBA8I:case i.lP.RGBA8UI:case i.lP.RGBA8_SNORM:case i.lP.SRGB8_ALPHA8:case i.lP.RGB9_E5:case i.lP.RGB10_A2UI:case i.lP.RGB10_A2:case i.Tg.DEPTH_STENCIL:case i.Tg.DEPTH_COMPONENT32F:case i.Tg.DEPTH24_STENCIL8:return 4;case i.Tg.DEPTH32F_STENCIL8:return 5;case i.lP.RGB16F:case i.lP.RGB16I:case i.lP.RGB16UI:return 6;case i.lP.RG32F:case i.lP.RG32I:case i.lP.RG32UI:case i.lP.RGBA16F:case i.lP.RGBA16I:case i.lP.RGBA16UI:return 8;case i.lP.RGB32F:case i.lP.RGB32I:case i.lP.RGB32UI:return 12;case i.lP.RGBA32F:case i.lP.RGBA32I:case i.lP.RGBA32UI:return 16;case i.q_.COMPRESSED_RGB_S3TC_DXT1_EXT:case i.q_.COMPRESSED_RGBA_S3TC_DXT1_EXT:return.5;case i.q_.COMPRESSED_RGBA_S3TC_DXT3_EXT:case i.q_.COMPRESSED_RGBA_S3TC_DXT5_EXT:return 1;case i.q_.COMPRESSED_R11_EAC:case i.q_.COMPRESSED_SIGNED_R11_EAC:case i.q_.COMPRESSED_RGB8_ETC2:case i.q_.COMPRESSED_SRGB8_ETC2:case i.q_.COMPRESSED_RGB8_PUNCHTHROUGH_ALPHA1_ETC2:case i.q_.COMPRESSED_SRGB8_PUNCHTHROUGH_ALPHA1_ETC2:return.5;case i.q_.COMPRESSED_RG11_EAC:case i.q_.COMPRESSED_SIGNED_RG11_EAC:case i.q_.COMPRESSED_RGBA8_ETC2_EAC:case i.q_.COMPRESSED_SRGB8_ALPHA8_ETC2_EAC:return 1}return 0}function x(o){if((0,B.Wi)(o))return 0;if("descriptor"in o)return o.glName?x(o.descriptor):0;const d=o.internalFormat||"pixelFormat"in o&&o.pixelFormat;if(!d)return 0;const r="hasMipmap"in o&&o.hasMipmap?1.3:1,a=o.width*o.height;return u(d)*a*r}},49353:(C,P,l)=>{l.d(P,{U:()=>N});var M=l(63290),B=l(62208),i=l(67969),S=l(26906);const b=M.Z.getLogger("esri.views.webgl.VertexArrayObject");class N{constructor(n,u,x,o,d=null){this._context=n,this._locations=u,this._layout=x,this._buffers=o,this._indexBuffer=d,this._glName=null,this._initialized=!1,n.instanceCounter.increment(i._g.VertexArrayObject,this)}get glName(){return this._glName}get context(){return this._context}get vertexBuffers(){return this._buffers}get indexBuffer(){return this._indexBuffer}get size(){return Object.keys(this._buffers).reduce((n,u)=>n+this._buffers[u].size,(0,B.pC)(this._indexBuffer)?this._indexBuffer.size:0)}get layout(){return this._layout}get locations(){return this._locations}dispose(n=!0){var u,x;if(this._context){if(this._glName){const o=null==(x=null==(u=this._context)?void 0:u.capabilities)?void 0:x.vao;o?(o.deleteVertexArray(this._glName),this._glName=null):b.warn("Leaked WebGL VAO")}if(this._context.getBoundVAO()===this&&this._context.bindVAO(null),n){for(const o in this._buffers)this._buffers[o].dispose(),delete this._buffers[o];this._indexBuffer=(0,B.O3)(this._indexBuffer)}this._context.instanceCounter.decrement(i._g.VertexArrayObject,this),this._context=null}else(this._glName||n&&Object.getOwnPropertyNames(this._buffers).length>0)&&b.warn("Leaked WebGL VAO")}initialize(){if(this._initialized)return;const n=this._context.capabilities.vao;if(n){const u=n.createVertexArray();n.bindVertexArray(u),this._bindLayout(),n.bindVertexArray(null),this._glName=u}this._initialized=!0}bind(){this.initialize();const n=this._context.capabilities.vao;n?n.bindVertexArray(this.glName):(this._context.bindVAO(null),this._bindLayout())}_bindLayout(){const{_buffers:n,_layout:u,_indexBuffer:x}=this;n||b.error("Vertex buffer dictionary is empty!");const o=this._context.gl;for(const d in n){const r=n[d];r||b.error("Vertex buffer is uninitialized!");const a=u[d];a||b.error("Vertex element descriptor is empty!"),(0,S.XP)(this._context,this._locations,r,a)}(0,B.pC)(x)&&(this._context.capabilities.vao?o.bindBuffer(o.ELEMENT_ARRAY_BUFFER,x.glName):this._context.bindBuffer(x))}unbind(){this.initialize();const n=this._context.capabilities.vao;n?n.bindVertexArray(null):this._unbindLayout()}_unbindLayout(){const{_buffers:n,_layout:u}=this;n||b.error("Vertex buffer dictionary is empty!");for(const x in n){const o=n[x];o||b.error("Vertex buffer is uninitialized!"),(0,S.UF)(this._context,this._locations,o,u[x])}(0,B.pC)(this._indexBuffer)&&this._context.unbindBuffer(this._indexBuffer.bufferType)}}}}]);