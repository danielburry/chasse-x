"use strict";var Nt=Object.defineProperty,Ht=Object.getOwnPropertySymbols,Yt=Object.prototype.hasOwnProperty,Vt=Object.prototype.propertyIsEnumerable,Xt=(Rt,yt,R)=>yt in Rt?Nt(Rt,yt,{enumerable:!0,configurable:!0,writable:!0,value:R}):Rt[yt]=R,Wt=(Rt,yt)=>{for(var R in yt||(yt={}))Yt.call(yt,R)&&Xt(Rt,R,yt[R]);if(Ht)for(var R of Ht(yt))Vt.call(yt,R)&&Xt(Rt,R,yt[R]);return Rt};(self.webpackChunkchasse_pwa_front=self.webpackChunkchasse_pwa_front||[]).push([[5909],{986:(Rt,yt,R)=>{R.d(yt,{E:()=>Q});const H=new(R(6879).Z);function Q(ht){if(!H.hasBidiChar(ht))return[ht,!1];let bt;return bt="rtl"===H.checkContextual(ht)?"IDNNN":"ICNNN",[H.bidiTransform(ht,bt,"VLYSN"),!0]}},36161:(Rt,yt,R)=>{R.d(yt,{I:()=>H,v:()=>Q});var ut=R(21286);function H(U,I,Y=0){const j=(0,ut.uZ)(U,0,S);for(let ot=0;ot<4;ot++)I[Y+ot]=Math.floor(256*xt(j*ht[ot]))}function Q(U,I=0){let Y=0;for(let j=0;j<4;j++)Y+=U[I+j]*bt[j];return Y}const ht=[1,256,65536,16777216],bt=[1/256,1/65536,1/16777216,1/4294967296],S=Q(new Uint8ClampedArray([255,255,255,255]));function xt(U){return U-Math.floor(U)}},72283:(Rt,yt,R)=>{R.d(yt,{GP:()=>ht,QK:()=>pt,XV:()=>wt,hh:()=>st,ov:()=>Z,qh:()=>kt,v1:()=>It,wp:()=>ft,zY:()=>Ot,zv:()=>zt});var ut=R(58817),H=R(91179),Q=R(97373);function ht(x){const V=(0,ut.d9)(x);return function ot(x){x&&((0,H.oU)(x)?j(x.rings):(0,H.l9)(x)?j(x.paths):(0,H.aW)(x)&&Y(x.points),bt(x))}(V),V}function bt(x){if(!x)return null;(0,H.wp)(x)?x.y=-x.y:(0,H.oU)(x)?xt(x.rings):(0,H.l9)(x)?xt(x.paths):(0,H.aW)(x)&&S(x.points)}function S(x){if(x){const V=x.length;for(let q=0;q<V;q++)x[q][1]=-x[q][1]}}function xt(x){if(x)for(const V of x)S(V)}function U(x){if(x)for(let V=x.length-1;V>0;--V)x[V][0]-=x[V-1][0],x[V][1]-=x[V-1][1]}function I(x){if(x)for(const V of x)U(V)}function Y(x){if(x){const V=x.length;for(let q=1;q<V;++q)x[q][0]+=x[q-1][0],x[q][1]+=x[q-1][1]}}function j(x){if(x)for(const V of x)Y(V)}function ft(x){x&&(bt(x),(0,H.oU)(x)?I(x.rings):(0,H.l9)(x)?I(x.paths):(0,H.aW)(x)&&U(x.points))}function Z(x){if(x)for(const V of x)st(V)}function st(x){x&&x.reverse()}function wt(x,V,q){return[x[0]+(V[0]-x[0])*q,x[1]+(V[1]-x[1])*q]}function pt(x){return!(!x||0===x.length)&&x[0][0]===x[x.length-1][0]&&x[0][1]===x[x.length-1][1]}function zt(x){return x[4]}function kt(x,V){x[4]=V}class It{constructor(V,q,k,D){this.acceptPolygon=q,this.acceptPolyline=k,this.geomUnitsPerPoint=D,this.pathCount=-1,this.pathIndex=-1,this.iteratePath=!1,V&&((0,H.oU)(V)?q&&(this.multiPath=V.rings,this.isClosed=!0):(0,H.l9)(V)?k&&(this.multiPath=V.paths,this.isClosed=!1):(0,H.YX)(V)&&q&&(this.multiPath=Lt(V).rings,this.isClosed=!0),this.multiPath&&(this.pathCount=this.multiPath.length)),this.internalPlacement=new Q.u}next(){if(!this.multiPath)return null;for(;this.iteratePath||this.pathIndex<this.pathCount-1;){this.iteratePath||this.pathIndex++;const V=this.processPath(this.multiPath[this.pathIndex]);if(V)return V}return this.pathCount=-1,this.pathIndex=-1,this.multiPath=null,null}}class Ot{constructor(V,q,k,D){this.inputGeometries=V,this.acceptPolygon=q,this.acceptPolyline=k,this.geomUnitsPerPoint=D,this.pathCount=-1,this.pathIndex=-1,this.iteratePath=!1}next(){for(;;){if(!this.multiPath){let V=this.inputGeometries.next();for(;V;){if((0,H.oU)(V)?this.acceptPolygon&&(this.multiPath=V.rings,this.isClosed=!0):(0,H.l9)(V)?this.acceptPolyline&&(this.multiPath=V.paths,this.isClosed=!1):(0,H.YX)(V)&&this.acceptPolygon&&(this.multiPath=Lt(V).rings,this.isClosed=!0),this.multiPath){this.pathCount=this.multiPath.length,this.pathIndex=-1;break}V=this.inputGeometries.next()}if(!this.multiPath)return null}for(;this.iteratePath||this.pathIndex<this.pathCount-1;){this.iteratePath||this.pathIndex++;const V=this.processPath(this.multiPath[this.pathIndex]);if(V)return V}this.pathCount=-1,this.pathIndex=-1,this.multiPath=null}}}function Lt(x){return{rings:[[[x.xmin,x.ymin],[x.xmin,x.ymax],[x.xmax,x.ymax],[x.xmax,x.ymin],[x.xmin,x.ymin]]]}}},29214:(Rt,yt,R)=>{R.d(yt,{M:()=>H}),R(58817);class H{constructor(bt){this._geometry=bt}next(){const bt=this._geometry;return this._geometry=null,bt}}},11004:(Rt,yt,R)=>{R.d(yt,{h:()=>Gt,W:()=>Ft});var ut=R(58817),H=R(91179),Q=R(72283);let ht=(()=>{class f{static local(){return null===f.instance&&(f.instance=new f),f.instance}execute(e,i,o,n){return new bt(e,i,o)}}return f.instance=null,f})();class bt{constructor(s,e,i){this._inputGeometries=s,this._angleTolerance=void 0!==e.angleTolerance?e.angleTolerance:120,this._maxCosAngle=Math.cos((1-Math.abs(this._angleTolerance)/180)*Math.PI)}next(){let s=this._inputGeometries.next();for(;s;){if((0,H.oU)(s)){this._isClosed=!0;const e=(0,ut.d9)(s);return this._processMultipath(e.rings),e}if((0,H.l9)(s)){this._isClosed=!1;const e=(0,ut.d9)(s);return this._processMultipath(e.paths),e}if((0,H.YX)(s)){if(this._maxCosAngle)return s;this._isClosed=!0;const e=[[s.xmin,s.ymin],[s.xmin,s.ymax],[s.xmax,s.ymax],[s.xmax,s.ymin],[s.xmin,s.ymin]];return this._processPath(e),{rings:[e]}}s=this._inputGeometries.next()}return null}_processMultipath(s){if(s)for(const e of s)this._processPath(e)}_processPath(s){if(s){let e,i,o,n,r,c,h=s.length,u=s[0];this._isClosed&&++h;for(let p=1;p<h;++p){let g;g=this._isClosed&&p===h-1?s[0]:s[p];const A=g[0]-u[0],T=g[1]-u[1],O=Math.sqrt(A*A+T*T);p>1&&O>0&&o>0&&(e*A+i*T)/O/o<=this._maxCosAngle&&(0,Q.qh)(u,1),1===p&&(n=A,r=T,c=O),O>0&&(u=g,e=A,i=T,o=O)}this._isClosed&&o>0&&c>0&&(e*n+i*r)/c/o<=this._maxCosAngle&&(0,Q.qh)(s[0],1)}}}var S=R(7547);const xt=.03;class U{constructor(){this._path=[]}path(){return this._path}addPath(s,e){e||s.reverse(),Array.prototype.push.apply(this._path,s),e||s.reverse()}static mergePath(s,e){e&&Array.prototype.push.apply(s,e)}startPath(s){this._path.push(s)}lineTo(s){this._path.push(s)}close(){const s=this._path;s.length>1&&(s[0][0]===s[s.length-1][0]&&s[0][1]===s[s.length-1][1]||s.push([s[0][0],s[0][1]]))}}class I{constructor(s=0,e=!1){}normalize(s){const e=Math.sqrt(s[0]*s[0]+s[1]*s[1]);0!==e&&(s[0]/=e,s[1]/=e)}calculateLength(s,e){const i=e[0]-s[0],o=e[1]-s[1];return Math.sqrt(i*i+o*o)}calculateSegLength(s,e){return this.calculateLength(s[e],s[e+1])}calculatePathLength(s){let e=0;const i=s?s.length:0;for(let o=0;o<i-1;++o)e+=this.calculateSegLength(s,o);return e}calculatePathArea(s){let e=0;const i=s?s.length:0;for(let o=0;o<i-1;++o)e+=(s[o+1][0]-s[o][0])*(s[o+1][1]+s[o][1]);return e/2}getCoord2D(s,e,i){return[s[0]+(e[0]-s[0])*i,s[1]+(e[1]-s[1])*i]}getSegCoord2D(s,e,i){return this.getCoord2D(s[e],s[e+1],i)}getAngle(s,e,i){return Math.atan2(e[1]-s[1],e[0]-s[0])}getSegAngle(s,e,i){return this.getAngle(s[e],s[e+1],i)}getAngleCS(s,e,i){const o=e[0]-s[0],n=e[1]-s[1],r=Math.sqrt(o*o+n*n);return r>0?[o/r,n/r]:[1,0]}getSegAngleCS(s,e,i){return this.getAngleCS(s[e],s[e+1],i)}cut(s,e,i,o){return[i<=0?s[e]:this.getSegCoord2D(s,e,i),o>=1?s[e+1]:this.getSegCoord2D(s,e,o)]}addSegment(s,e,i){i&&s.push(e[0]),s.push(e[1])}getSubCurve(s,e,i){const o=[];return this.appendSubCurve(o,s,e,i)?o:null}appendSubCurve(s,e,i,o){const n=e?e.length-1:0;let r=0,c=!0,h=0;for(;h<n;){const u=this.calculateSegLength(e,h);if(0!==u){if(c){if(r+u>i){let g=1,A=!1;r+u>=o&&(g=(o-r)/u,A=!0);const T=this.cut(e,h,(i-r)/u,g);if(T&&this.addSegment(s,T,c),A)break;c=!1}}else{if(r+u>o){const p=this.cut(e,h,0,(o-r)/u);p&&this.addSegment(s,p,c);break}this.addSegment(s,[e[h],e[h+1]],c)}r+=u,++h}else++h}return!0}getCIMPointAlong(s,e){const i=s?s.length-1:0;let o=0,n=-1;for(;n<i;){++n;const r=this.calculateSegLength(s,n);if(0!==r){if(o+r>e)return this.getCoord2D(s[n],s[n+1],(e-o)/r);o+=r}}return null}isEmpty(s,e){if(!s||s.length<=1)return!0;const i=s?s.length-1:0;let o=-1;for(;o<i;)if(++o,s[o+1][0]!==s[o][0]||s[o+1][1]!==s[o][1]||e&&s[o+1][2]!==s[o][2])return!1;return!0}offset(s,e,i,o,n){if(!s||s.length<2)return null;let r=0,c=s[r++],h=r;for(;r<s.length;){const A=s[r];A[0]===c[0]&&A[1]===c[1]||(r!==h&&(s[h]=s[r]),c=s[h++]),r++}const u=s[0][0]===s[h-1][0]&&s[0][1]===s[h-1][1];if(u&&--h,h<(u?3:2))return null;const p=[];c=u?s[h-1]:null;let g=s[0];for(let A=0;A<h;A++){const T=A===h-1?u?s[0]:null:s[A+1];if(c)if(T){const O=[T[0]-g[0],T[1]-g[1]];this.normalize(O);const B=[g[0]-c[0],g[1]-c[1]];this.normalize(B);const tt=B[0]*O[1]-B[1]*O[0],At=B[0]*O[0]+B[1]*O[1];if(0===tt&&1===At){g=T;continue}if(tt>=0==e<=0){if(At<1){const Et=[O[0]-B[0],O[1]-B[1]];this.normalize(Et);const St=Math.sqrt((1+At)/2);if(St>1/o){const Mt=-Math.abs(e)/St;p.push([g[0]-Et[0]*Mt,g[1]-Et[1]*Mt])}}}else switch(i){case S.id.Mitered:{const Et=Math.sqrt((1+At)/2);if(Et>0&&1/Et<o){const St=[O[0]-B[0],O[1]-B[1]];this.normalize(St);const Mt=Math.abs(e)/Et;p.push([g[0]-St[0]*Mt,g[1]-St[1]*Mt]);break}}case S.id.Bevelled:p.push([g[0]+B[1]*e,g[1]-B[0]*e]),p.push([g[0]+O[1]*e,g[1]-O[0]*e]);break;case S.id.Rounded:if(At<1){p.push([g[0]+B[1]*e,g[1]-B[0]*e]);const Et=Math.floor(2.5*(1-At));if(Et>0){const St=1/Et;let Mt=St;for(let Bt=1;Bt<Et;Bt++,Mt+=St){const Ut=[B[1]*(1-Mt)+O[1]*Mt,-B[0]*(1-Mt)-O[0]*Mt];this.normalize(Ut),p.push([g[0]+Ut[0]*e,g[1]+Ut[1]*e])}}p.push([g[0]+O[1]*e,g[1]-O[0]*e])}break;default:if(tt<0)p.push([g[0]+(B[1]+B[0])*e,g[1]+(B[1]-B[0])*e]),p.push([g[0]+(O[1]-O[0])*e,g[1]-(O[0]+O[1])*e]);else{const Et=Math.sqrt((1+Math.abs(At))/2),St=[O[0]-B[0],O[1]-B[1]];this.normalize(St);const Mt=e/Et;p.push([g[0]-St[0]*Mt,g[1]-St[1]*Mt])}}}else{const O=[g[0]-c[0],g[1]-c[1]];this.normalize(O),p.push([g[0]+O[1]*e,g[1]-O[0]*e])}else{const O=[T[0]-g[0],T[1]-g[1]];this.normalize(O),p.push([g[0]+O[1]*e,g[1]-O[0]*e])}c=g,g=T}return p.length<(u?3:2)?null:(u&&p.push([p[0][0],p[0][1]]),p)}}const Y=1.7320508075688772,ot=S.TF.OpenEnded;let ft=(()=>{class f{static local(){return null===f.instance&&(f.instance=new f),f.instance}execute(e,i,o,n){return new Z(e,i,o)}}return f.instance=null,f})();class Z extends Q.zY{constructor(s,e,i){super(s,!1,!0),this._curveHelper=new I,this._width=(void 0!==e.width?e.width:5)*i,this._arrowType=void 0!==e.geometricEffectArrowType?e.geometricEffectArrowType:void 0!==e.arrowType?e.arrowType:ot,this._offsetFlattenError=xt*i}processPath(s){switch(this._arrowType){case S.TF.OpenEnded:default:return this._constructSimpleArrow(s,!0);case S.TF.Block:return this._constructSimpleArrow(s,!1);case S.TF.Crossed:return this._constructCrossedArrow(s)}}_constructSimpleArrow(s,e){const i=this._curveHelper.calculatePathLength(s);let o=this._width;i<2*o&&(o=i/2);const n=this._curveHelper.getSubCurve(s,0,i-o);if(!n)return null;const r=o/2;if(this._curveHelper.isEmpty(n,!1))return null;const c=this._constructOffset(n,-r);if(!c)return null;const h=this._constructOffset(n,r);if(!h)return null;const u=this._constructArrowBasePoint(c,-r/2);if(!u)return null;const p=this._constructArrowBasePoint(h,r/2);if(!p)return null;const g=s[s.length-1];e||(this._makeControlPoint(h,!0),this._makeControlPoint(c,!0));const A=new U;return A.addPath(h,!0),A.lineTo(p),this._makeControlPoint(A.path()),A.lineTo(g),this._makeControlPoint(A.path()),A.lineTo(u),this._makeControlPoint(A.path()),A.addPath(c,!1),e?{paths:[A.path()]}:(A.close(),{rings:[A.path()]})}_constructCrossedArrow(s){const e=this._curveHelper.calculatePathLength(s);let i=this._width;e<i*(1+Y+1)&&(i=e/(1+Y+1));const o=this._curveHelper.getSubCurve(s,0,e-i*(1+Y));if(!o)return null;const n=i/2;if(this._curveHelper.isEmpty(o,!1))return null;const r=this._constructOffset(o,n);if(!r)return null;const c=this._constructOffset(o,-n);if(!c)return null;const h=this._curveHelper.getSubCurve(s,0,e-i);if(!h||this._curveHelper.isEmpty(h,!1))return null;const u=this._constructOffset(h,n);if(!u)return null;const p=this._constructOffset(h,-n);if(!p)return null;const g=u[u.length-1],A=this._constructArrowBasePoint(u,n/2);if(!A)return null;const T=p[p.length-1],O=this._constructArrowBasePoint(p,-n/2);if(!O)return null;const B=s[s.length-1];this._makeControlPoint(r,!1),this._makeControlPoint(c,!1);const tt=new U;return tt.addPath(r,!0),this._makeControlPoint(tt.path()),tt.lineTo(T),tt.lineTo(O),this._makeControlPoint(tt.path()),tt.lineTo(B),this._makeControlPoint(tt.path()),tt.lineTo(A),this._makeControlPoint(tt.path()),tt.lineTo(g),this._makeControlPoint(tt.path()),tt.addPath(c,!1),{paths:[tt.path()]}}_constructOffset(s,e){return this._curveHelper.offset(s,e,S.id.Rounded,4,this._offsetFlattenError)}_constructArrowBasePoint(s,e){if(!s||s.length<2)return null;const i=s[s.length-2],o=s[s.length-1],n=[o[0]-i[0],o[1]-i[1]];return this._curveHelper.normalize(n),[o[0]+n[1]*e,o[1]-n[0]*e]}_makeControlPoint(s,e=!1){(0,Q.qh)(e?s[0]:s[s.length-1],1)}}let st=(()=>{class f{static local(){return null===f.instance&&(f.instance=new f),f.instance}execute(e,i,o,n){return new wt(e,i,o,n)}}return f.instance=null,f})();class wt{constructor(s,e,i,o){this._inputGeometries=s,this._curveHelper=new I,this._size=(void 0!==e.size?e.size:1)*i,this._offsetFlattenError=xt*i}next(){let s=this._inputGeometries.next();for(;s;){if((0,H.YX)(s))if(this._size>0){const i=this._curveHelper.offset([[s.xmin,s.ymin],[s.xmin,s.ymax],[s.xmax,s.ymax],[s.xmax,s.ymin],[s.xmin,s.ymin]],this._size,S.id.Rounded,4,this._offsetFlattenError);if(i)return{rings:[i]}}else{if(!(this._size<0))return s;if(Math.min(s.xmax-s.xmin,s.ymax-s.ymin)+2*this._size>0)return{xmin:s.xmin-this._size,xmax:s.xmax+this._size,ymin:s.ymin-this._size,ymax:s.ymax+this._size}}if((0,H.oU)(s)){if(0===this._size)return s;const e=[];for(const i of s.rings){const o=this._curveHelper.offset(i,this._size,S.id.Rounded,4,this._offsetFlattenError);o&&e.push(o)}if(e.length)return{rings:e}}if((0,H.l9)(s)&&this._size>0){const e=[];for(const i of s.paths)if(i&&i.length>1){const o=this._curveHelper.offset(i,this._size,S.id.Rounded,4,this._offsetFlattenError),n=this._curveHelper.offset(i,-this._size,S.id.Rounded,4,this._offsetFlattenError);if(o&&n){for(let r=n.length-1;r>=0;r--)o.push(n[r]);o.push([o[0][0],o[0][1]]),e.push(o)}}if(e.length)return{rings:e}}(0,H.wp)(s),s=this._inputGeometries.next()}return null}}let pt=(()=>{class f{static local(){return null===f.instance&&(f.instance=new f),f.instance}execute(e,i,o,n){return new zt(e,i,o)}}return f.instance=null,f})();class zt{constructor(s,e,i){var o;this._default_point_size=20,this._inputGeometries=s,this._geomUnitsPerPoint=i,this._rule=null!=(o=e.rule)?o:S.Em.FullGeometry,this._default_size=this._default_point_size*i}next(){let s;for(;s=this._inputGeometries.next();){let e;if((0,H.wp)(s)?e=this._processGeom([[[s.x,s.y]]]):(0,H.aW)(s)?e=this._processGeom([s.points]):(0,H.l9)(s)?e=this._processGeom(s.paths):(0,H.oU)(s)&&(e=this._processGeom(s.rings)),e&&e.length)return{paths:e}}return null}_clone(s){return[s[0],s[1]]}_mid(s,e){return[(s[0]+e[0])/2,(s[1]+e[1])/2]}_mix(s,e,i,o){return[s[0]*e+i[0]*o,s[1]*e+i[1]*o]}_add(s,e){return[s[0]+e[0],s[1]+e[1]]}_add2(s,e,i){return[s[0]+e,s[1]+i]}_sub(s,e){return[s[0]-e[0],s[1]-e[1]]}_dist(s,e){return Math.sqrt((s[0]-e[0])*(s[0]-e[0])+(s[1]-e[1])*(s[1]-e[1]))}_norm(s){return Math.sqrt(s[0]*s[0]+s[1]*s[1])}_normalize(s,e=1){const i=e/this._norm(s);s[0]*=i,s[1]*=i}_leftPerpendicular(s){const i=s[0];s[0]=-s[1],s[1]=i}_leftPerp(s){return[-s[1],s[0]]}_rightPerpendicular(s){const i=-s[0];s[0]=s[1],s[1]=i}_rightPerp(s){return[s[1],-s[0]]}_dotProduct(s,e){return s[0]*e[0]+s[1]*e[1]}_crossProduct(s,e){return s[0]*e[1]-s[1]*e[0]}_rotateDirect(s,e,i){const n=s[0]*i+s[1]*e;s[0]=s[0]*e-s[1]*i,s[1]=n}_makeCtrlPt(s){const e=[s[0],s[1]];return(0,Q.qh)(e,1),e}_addAngledTicks(s,e,i,o){const n=this._sub(i,e);this._normalize(n);const r=this._crossProduct(n,this._sub(o,e));let c;c=r>0?this._rightPerp(n):this._leftPerp(n);const h=Math.abs(r)/2,u=[];u.push([e[0]+(c[0]-n[0])*h,e[1]+(c[1]-n[1])*h]),u.push(e),u.push(i),u.push([i[0]+(c[0]+n[0])*h,i[1]+(c[1]+n[1])*h]),s.push(u)}_addBezier2(s,e,i,o,n){if(0==n--)return void s.push(o);const r=this._mid(e,i),c=this._mid(i,o),h=this._mid(r,c);this._addBezier2(s,e,r,h,n),this._addBezier2(s,h,c,o,n)}_addBezier3(s,e,i,o,n,r){if(0==r--)return void s.push(n);const c=this._mid(e,i),h=this._mid(i,o),u=this._mid(o,n),p=this._mid(c,h),g=this._mid(h,u),A=this._mid(p,g);this._addBezier3(s,e,c,p,A,r),this._addBezier3(s,A,g,u,n,r)}_add90DegArc(s,e,i,o,n){const r=null!=n?n:this._crossProduct(this._sub(i,e),this._sub(o,e))>0,c=this._mid(e,i),h=this._sub(c,e);r?this._leftPerpendicular(h):this._rightPerpendicular(h),c[0]+=h[0],c[1]+=h[1],this._addBezier3(s,e,this._mix(e,.33333,c,.66667),this._mix(i,.33333,c,.66667),i,4)}_addArrow(s,e,i){const o=e[0],n=e[1],r=e[e.length-1],c=this._sub(o,n);this._normalize(c);const h=this._crossProduct(c,this._sub(r,n)),u=.5*h,p=this._leftPerp(c),g=[r[0]-p[0]*h,r[1]-p[1]*h],A=e.length-1,T=[];T.push(i?[-p[0],-p[1]]:p);let O=[-c[0],-c[1]];for(let B=1;B<A-1;B++){const tt=this._sub(e[B+1],e[B]);this._normalize(tt);const At=this._dotProduct(tt,O),Et=this._crossProduct(tt,O),St=Math.sqrt((1+At)/2),Mt=this._sub(tt,O);this._normalize(Mt),Mt[0]/=St,Mt[1]/=St,T.push(Et<0?[-Mt[0],-Mt[1]]:Mt),O=tt}T.push(this._rightPerp(O));for(let B=T.length-1;B>0;B--)s.push([e[B][0]+T[B][0]*u,e[B][1]+T[B][1]*u]);s.push([g[0]+T[0][0]*u,g[1]+T[0][1]*u]),s.push([g[0]+T[0][0]*h,g[1]+T[0][1]*h]),s.push(o),s.push([g[0]-T[0][0]*h,g[1]-T[0][1]*h]),s.push([g[0]-T[0][0]*u,g[1]-T[0][1]*u]);for(let B=1;B<T.length;B++)s.push([e[B][0]-T[B][0]*u,e[B][1]-T[B][1]*u])}_cp2(s,e,i){return s.length>=2?s[1]:this._add2(s[0],e*this._default_size,i*this._default_size)}_cp3(s,e,i,o){if(s.length>=3)return s[2];const n=this._mix(s[0],1-i,e,i),r=this._sub(e,s[0]);return this._normalize(r),this._rightPerpendicular(r),[n[0]+r[0]*o*this._default_size,n[1]+r[1]*o*this._default_size]}_arrowPath(s){if(s.length>2)return s;const e=s[0],i=this._cp2(s,-4,0),o=this._sub(e,i);this._normalize(o);const n=this._rightPerp(o);return[e,i,[e[0]+(n[0]-o[0])*this._default_size,e[1]+(n[1]-o[1])*this._default_size]]}_arrowLastSeg(s){const e=s[0],i=this._cp2(s,-4,0);let o;if(s.length>=3)o=s[s.length-1];else{const n=this._sub(e,i);this._normalize(n);const r=this._rightPerp(n);o=[e[0]+(r[0]-n[0])*this._default_size,e[1]+(r[1]-n[1])*this._default_size]}return[i,o]}_processGeom(s){if(!s)return null;const e=[];for(const i of s){if(!i||0===i.length)continue;const o=i.length;let n=i[0];switch(this._rule){case S.Em.PerpendicularFromFirstSegment:{const r=this._cp2(i,0,-1),c=this._cp3(i,r,.5,4),h=[];h.push(c),h.push(this._mid(n,r)),e.push(h);break}case S.Em.ReversedFirstSegment:{const r=this._cp2(i,0,-1);e.push([r,n]);break}case S.Em.PerpendicularToSecondSegment:{const r=this._cp2(i,-4,1),c=this._cp3(i,r,.882353,-1.94),h=[];h.push(this._mid(r,c)),h.push(n),e.push(h);break}case S.Em.SecondSegmentWithTicks:{const r=this._cp2(i,-4,1),c=this._cp3(i,r,.882353,-1.94),h=this._sub(c,r);let u;u=this._crossProduct(h,this._sub(n,r))>0?this._rightPerp(u):this._leftPerp(h);const p=[];p.push([r[0]+(u[0]-h[0])/3,r[1]+(u[1]-h[1])/3]),p.push(r),p.push(c),p.push([c[0]+(u[0]+h[0])/3,c[1]+(u[1]+h[1])/3]),e.push(p);break}case S.Em.DoublePerpendicular:{const r=this._cp2(i,0,-1),c=this._cp3(i,r,.5,3),h=this._mid(n,r),u=this._sub(h,c);this._normalize(u);const p=this._crossProduct(u,this._sub(n,c));this._leftPerpendicular(u);const g=[];g.push(n),g.push([c[0]+u[0]*p,c[1]+u[1]*p]),e.push(g);const A=[];A.push([c[0]-u[0]*p,c[1]-u[1]*p]),A.push(r),e.push(A);break}case S.Em.OppositeToFirstSegment:{const r=this._cp2(i,0,-1),c=this._cp3(i,r,.5,3),h=this._mid(n,r),u=this._sub(h,c);this._normalize(u);const p=this._crossProduct(u,this._sub(n,c));this._leftPerpendicular(u);const g=[];g.push([c[0]+u[0]*p,c[1]+u[1]*p]),g.push([c[0]-u[0]*p,c[1]-u[1]*p]),e.push(g);break}case S.Em.TriplePerpendicular:{const r=this._cp2(i,0,-1),c=this._cp3(i,r,.5,4),h=this._mid(n,r),u=this._sub(h,c);this._normalize(u);const p=this._crossProduct(u,this._sub(n,c));this._leftPerpendicular(u);const g=[];g.push([c[0]+u[0]*p*.8,c[1]+u[1]*p*.8]),g.push([h[0]+.8*(n[0]-h[0]),h[1]+.8*(n[1]-h[1])]),e.push(g),e.push([c,h]);const A=[];A.push([c[0]-u[0]*p*.8,c[1]-u[1]*p*.8]),A.push([h[0]+.8*(r[0]-h[0]),h[1]+.8*(r[1]-h[1])]),e.push(A);break}case S.Em.HalfCircleFirstSegment:{const r=this._cp2(i,0,-1),c=this._cp3(i,r,.5,4),h=this._mid(n,r);let u=this._sub(r,n);const p=Math.cos(Math.PI/18),g=Math.sin(Math.PI/18),A=Math.sqrt((1+p)/2),T=Math.sqrt((1-p)/2),O=[];let B;this._crossProduct(u,this._sub(c,n))>0?(O.push(n),u=this._sub(n,h),B=r):(O.push(r),u=this._sub(r,h),B=n),this._rotateDirect(u,A,T),u[0]/=A,u[1]/=A;for(let tt=1;tt<=18;tt++)O.push(this._add(h,u)),this._rotateDirect(u,p,g);O.push(B),e.push(O);break}case S.Em.HalfCircleSecondSegment:{const r=this._cp2(i,0,-1),c=this._cp3(i,r,1,-1);let h=this._sub(n,r);this._normalize(h);const u=this._crossProduct(h,this._sub(c,r))/2;this._leftPerpendicular(h);const p=[r[0]+h[0]*u,r[1]+h[1]*u];h=this._sub(r,p);const g=Math.cos(Math.PI/18);let A=Math.sin(Math.PI/18);u>0&&(A=-A);const T=[r];for(let O=1;O<=18;O++)this._rotateDirect(h,g,A),T.push(this._add(p,h));e.push(T);break}case S.Em.HalfCircleExtended:{const r=this._cp2(i,0,-2),c=this._cp3(i,r,1,-1);let h;if(o>=4)h=i[3];else{const O=this._sub(n,r);h=this._add(c,O)}const u=this._dist(r,c)/2/.75,p=this._sub(r,n);this._normalize(p,u);const g=this._sub(c,h);this._normalize(g,u),e.push([h,c]);const T=[this._clone(c)];this._addBezier3(T,c,this._add(c,g),this._add(r,p),r,4),T.push(n),e.push(T);break}case S.Em.OpenCircle:{const r=this._cp2(i,-2,0),c=this._sub(r,n),h=Math.cos(Math.PI/18),u=-Math.sin(Math.PI/18),p=[r];for(let g=1;g<=33;g++)this._rotateDirect(c,h,u),p.push(this._add(n,c));e.push(p);break}case S.Em.CoverageEdgesWithTicks:{const r=this._cp2(i,0,-1);let c,h;if(o>=3)c=i[2];else{const A=this._sub(r,n),T=this._leftPerp(A);c=[n[0]+T[0]-.25*A[0],n[1]+T[1]-.25*A[1]]}if(o>=4)h=i[3];else{const A=this._mid(n,r),T=this._sub(n,r);this._normalize(T),this._leftPerpendicular(T);const O=this._crossProduct(T,this._sub(c,A));this._rightPerpendicular(T),h=[c[0]+T[0]*O*2,c[1]+T[1]*O*2]}const u=this._sub(r,n);let p,g;p=this._crossProduct(u,this._sub(c,n))>0?this._rightPerp(u):this._leftPerp(u),g=[],g.push(c),g.push(n),g.push([n[0]+(p[0]-u[0])/3,n[1]+(p[1]-u[1])/3]),e.push(g),p=this._crossProduct(u,this._sub(h,r))>0?this._rightPerp(p):this._leftPerp(u),g=[],g.push([r[0]+(p[0]+u[0])/3,r[1]+(p[1]+u[1])/3]),g.push(r),g.push(h),e.push(g);break}case S.Em.GapExtentWithDoubleTicks:{const r=this._cp2(i,0,2),c=this._cp3(i,r,0,1);let h;if(o>=4)h=i[3];else{const u=this._sub(r,n);h=this._add(c,u)}this._addAngledTicks(e,n,r,this._mid(c,h)),this._addAngledTicks(e,c,h,this._mid(n,r));break}case S.Em.GapExtentMidline:{const r=this._cp2(i,2,0),c=this._cp3(i,r,0,1);let h;if(o>=4)h=i[3];else{const p=this._sub(r,n);h=this._add(c,p)}const u=[];u.push(this._mid(n,c)),u.push(this._mid(r,h)),e.push(u);break}case S.Em.Chevron:{const r=this._cp2(i,-1,-1);let c;if(o>=3)c=i[2];else{const h=this._sub(r,n);this._leftPerpendicular(h),c=this._add(n,h)}e.push([r,this._makeCtrlPt(n),c]);break}case S.Em.PerpendicularWithArc:{const r=this._cp2(i,0,-2),c=this._cp3(i,r,.5,-1);let h=this._sub(r,n);const u=this._norm(h);h[0]/=u,h[1]/=u;const p=this._crossProduct(h,this._sub(c,n));let g=this._dotProduct(h,this._sub(c,n));g<.05*u?g=.05*u:g>.95*u&&(g=.95*u);const A=[n[0]+h[0]*g,n[1]+h[1]*g];this._leftPerpendicular(h);let T=[];T.push([A[0]-h[0]*p,A[1]-h[1]*p]),T.push([A[0]+h[0]*p,A[1]+h[1]*p]),e.push(T);const O=[r[0]+h[0]*p,r[1]+h[1]*p];h=this._sub(r,O);const B=Math.cos(Math.PI/18);let tt=Math.sin(Math.PI/18);p<0&&(tt=-tt),T=[n,r];for(let At=1;At<=9;At++)this._rotateDirect(h,B,tt),T.push(this._add(O,h));e.push(T);break}case S.Em.ClosedHalfCircle:{const r=this._cp2(i,2,0),c=this._mid(n,r),h=this._sub(r,c),u=Math.cos(Math.PI/18),p=Math.sin(Math.PI/18),g=[n,r];for(let A=1;A<=18;A++)this._rotateDirect(h,u,p),g.push(this._add(c,h));e.push(g);break}case S.Em.TripleParallelExtended:{const r=this._cp2(i,0,-2),c=this._cp3(i,r,1,-2),h=this._mid(n,r),u=this._sub(c,r);this._normalize(u);const p=Math.abs(this._crossProduct(u,this._sub(h,r)))/2,g=this._dist(r,c),A=[r,n];A.push([n[0]+u[0]*g*.5,n[1]+u[1]*g*.5]),e.push(A);const T=[];T.push([h[0]-u[0]*p,h[1]-u[1]*p]),T.push([h[0]+u[0]*g*.375,h[1]+u[1]*g*.375]),(0,Q.qh)(T[T.length-1],1),T.push([h[0]+u[0]*g*.75,h[1]+u[1]*g*.75]),e.push(T),e.push([r,c]);break}case S.Em.ParallelWithTicks:{const r=this._cp2(i,3,0),c=this._cp3(i,r,.5,-1),h=this._sub(c,r);this._normalize(h);const u=this._crossProduct(h,this._sub(c,n));this._leftPerpendicular(h),this._addAngledTicks(e,n,r,c),this._addAngledTicks(e,this._mix(n,1,h,u),this._mix(r,1,h,u),this._mid(n,r));break}case S.Em.Parallel:{const r=this._cp2(i,3,0),c=this._cp3(i,r,.5,-1),h=this._sub(r,n);this._normalize(h);const u=this._leftPerp(h),p=this._crossProduct(h,this._sub(c,n));let g=[n,r];e.push(g),g=[],g.push([n[0]+u[0]*p,n[1]+u[1]*p]),g.push([r[0]+u[0]*p,r[1]+u[1]*p]),e.push(g);break}case S.Em.PerpendicularToFirstSegment:{const r=this._cp2(i,3,0),c=this._cp3(i,r,.5,-1),h=this._mid(n,r),u=this._sub(r,n);this._normalize(u);const p=this._crossProduct(u,this._sub(c,n));this._leftPerpendicular(u);const g=[];g.push([h[0]-u[0]*p*.25,h[1]-u[1]*p*.25]),g.push([h[0]+u[0]*p*1.25,h[1]+u[1]*p*1.25]),e.push(g);break}case S.Em.ParallelOffset:{const r=this._cp2(i,3,0),c=this._cp3(i,r,.5,-1),h=this._sub(r,n);this._normalize(h);const u=this._crossProduct(h,this._sub(c,n));this._leftPerpendicular(h);const p=[];p.push([n[0]-h[0]*u,n[1]-h[1]*u]),p.push([r[0]-h[0]*u,r[1]-h[1]*u]),e.push(p);const g=[];g.push([n[0]+h[0]*u,n[1]+h[1]*u]),g.push([r[0]+h[0]*u,r[1]+h[1]*u]),e.push(g);break}case S.Em.OffsetOpposite:{const r=this._cp2(i,3,0),c=this._cp3(i,r,.5,-1),h=this._sub(r,n);this._normalize(h);const u=this._crossProduct(h,this._sub(c,n));this._leftPerpendicular(h);const p=[];p.push([n[0]-h[0]*u,n[1]-h[1]*u]),p.push([r[0]-h[0]*u,r[1]-h[1]*u]),e.push(p);break}case S.Em.OffsetSame:{const r=this._cp2(i,3,0),c=this._cp3(i,r,.5,-1),h=this._sub(r,n);this._normalize(h);const u=this._crossProduct(h,this._sub(c,n));this._leftPerpendicular(h);const p=[];p.push([n[0]+h[0]*u,n[1]+h[1]*u]),p.push([r[0]+h[0]*u,r[1]+h[1]*u]),e.push(p);break}case S.Em.CircleWithArc:{let r=this._cp2(i,3,0);const c=this._cp3(i,r,.5,-1);let h,u;if(o>=4)h=i[3],u=this._crossProduct(this._sub(h,r),this._sub(c,r))>0;else{h=r,u=this._crossProduct(this._sub(h,n),this._sub(c,n))>0;const O=24*this._geomUnitsPerPoint,B=this._sub(h,n);this._normalize(B,O);const tt=Math.sqrt(2)/2;this._rotateDirect(B,tt,u?tt:-tt),r=this._add(n,B)}const p=this._sub(r,n),g=Math.cos(Math.PI/18),A=Math.sin(Math.PI/18),T=[r];for(let O=1;O<=36;O++)this._rotateDirect(p,g,A),T.push(this._add(n,p));this._add90DegArc(T,r,h,c,u),(0,Q.qh)(T[T.length-8],1),e.push(T);break}case S.Em.DoubleJog:{let r,c,h=this._cp2(i,-3,1);if(r=o>=3?i[2]:this._add(n,this._sub(n,h)),o>=4)c=i[3];else{const At=n;n=h,c=r;const Et=this._dist(n,At),St=this._dist(c,At);let Mt=30*this._geomUnitsPerPoint;.5*Et<Mt&&(Mt=.5*Et),.5*St<Mt&&(Mt=.5*St),h=this._mix(n,Mt/Et,At,(Et-Mt)/Et),r=this._mix(c,Mt/St,At,(St-Mt)/St)}const u=this._mid(n,h),p=this._mid(c,r),g=this._dist(n,h),A=this._dist(r,c);let T=Math.min(g,A)/8;T=Math.min(T,24*this._geomUnitsPerPoint);const O=Math.cos(Math.PI/4);let B=this._sub(n,h);this._normalize(B,T),this._crossProduct(B,this._sub(c,h))>0?this._rotateDirect(B,O,-O):this._rotateDirect(B,O,O);let tt=[];tt.push(h),tt.push(this._add(u,B)),tt.push(this._sub(u,B)),tt.push(n),e.push(tt),B=this._sub(c,r),this._normalize(B,T),this._crossProduct(B,this._sub(n,r))<0?this._rotateDirect(B,O,O):this._rotateDirect(B,O,-O),tt=[],tt.push(r),tt.push(this._add(p,B)),tt.push(this._sub(p,B)),tt.push(c),e.push(tt);break}case S.Em.PerpendicularOffset:{const r=this._cp2(i,-4,1),c=this._cp3(i,r,.882353,-1.94),h=this._sub(c,r);this._crossProduct(h,this._sub(n,r))>0?this._rightPerpendicular(h):this._leftPerpendicular(h);const u=[h[0]/8,h[1]/8],p=this._sub(this._mid(r,c),u);e.push([p,n]);break}case S.Em.LineExcludingLastSegment:{const r=this._arrowPath(i),c=[];let h=r.length-2;for(;h--;)c.push(r[h]);e.push(c);break}case S.Em.MultivertexArrow:{const r=this._arrowPath(i),c=[];this._addArrow(c,r,!1),e.push(c);break}case S.Em.CrossedArrow:{const r=this._arrowPath(i),c=[];this._addArrow(c,r,!0),e.push(c);break}case S.Em.ChevronArrow:{const[r,c]=this._arrowLastSeg(i),h=10*this._geomUnitsPerPoint,u=this._sub(n,r);this._normalize(u);const p=this._crossProduct(u,this._sub(c,r)),g=this._leftPerp(u),A=[c[0]-g[0]*p*2,c[1]-g[1]*p*2],T=[];T.push([c[0]+u[0]*h,c[1]+u[1]*h]),T.push(n),T.push([A[0]+u[0]*h,A[1]+u[1]*h]),e.push(T);break}case S.Em.ChevronArrowOffset:{const[r,c]=this._arrowLastSeg(i),h=this._sub(n,r);this._normalize(h);const u=this._crossProduct(h,this._sub(c,r));this._leftPerpendicular(h);const p=[c[0]-h[0]*u,c[1]-h[1]*u],g=[];g.push([p[0]+h[0]*u*.5,p[1]+h[1]*u*.5]),g.push(this._mid(p,n)),g.push([p[0]-h[0]*u*.5,p[1]-h[1]*u*.5]),e.push(g);break}case S.Em.PartialFirstSegment:{const[r,c]=this._arrowLastSeg(i),h=this._sub(n,r);this._normalize(h);const u=this._crossProduct(h,this._sub(c,r));this._leftPerpendicular(h),e.push([r,[c[0]-h[0]*u,c[1]-h[1]*u]]);break}case S.Em.Arch:{const r=this._cp2(i,0,-1),c=this._cp3(i,r,.5,1),h=this._sub(n,r),u=this._mix(c,1,h,.55),p=this._mix(c,1,h,-.55),g=[n];this._addBezier2(g,n,u,c,4),this._addBezier2(g,c,p,r,4),e.push(g);break}case S.Em.CurvedParallelTicks:{const r=this._cp2(i,-4,1),c=this._cp3(i,r,.882353,-1.94),h=this._sub(c,r);this._crossProduct(h,this._sub(n,r))>0?this._rightPerpendicular(h):this._leftPerpendicular(h);const u=[h[0]/8,h[1]/8],p=this._sub(this._mid(r,c),u),g=this._sub(this._mix(r,.75,c,.25),u),A=this._sub(this._mix(r,.25,c,.75),u),T=[r];this._addBezier2(T,r,g,p,3),this._addBezier2(T,p,A,c,3),e.push(T);for(let O=0;O<8;O++){const B=T[2*O+1],tt=[this._clone(B)];tt.push(this._add(B,[h[0]/4,h[1]/4])),e.push(tt)}break}case S.Em.Arc90Degrees:{const r=this._cp2(i,0,-1),c=this._cp3(i,r,.5,1),h=[r];this._add90DegArc(h,r,n,c),e.push(h);break}default:e.push(i)}}return e}}let kt=(()=>{class f{static local(){return null===f.instance&&(f.instance=new f),f.instance}execute(e,i,o,n){return new It(e,i,o)}}return f.instance=null,f})();class It extends Q.zY{constructor(s,e,i){super(s,!0,!0),this._curveHelper=new I,this._beginCut=(void 0!==e.beginCut?e.beginCut:1)*i,this._endCut=(void 0!==e.endCut?e.endCut:1)*i,this._middleCut=(void 0!==e.middleCut?e.middleCut:0)*i,this._invert=void 0!==e.invert&&e.invert,this._beginCut<0&&(this._beginCut=0),this._endCut<0&&(this._endCut=0),this._middleCut<0&&(this._middleCut=0)}processPath(s){const e=this._beginCut,i=this._endCut,o=this._middleCut,n=this._curveHelper.calculatePathLength(s),r=[];if(this._invert){if(0!==e||0!==i||0!==o)if(e+i+o>=n)r.push(s);else{let c=this._curveHelper.getSubCurve(s,0,e);c&&r.push(c),c=this._curveHelper.getSubCurve(s,.5*(n-o),.5*(n+o)),c&&r.push(c),c=this._curveHelper.getSubCurve(s,n-i,i),c&&r.push(c)}}else if(0===e&&0===i&&0===o)r.push(s);else if(!(e+i+o>=n))if(0===o){const c=this._curveHelper.getSubCurve(s,e,n-i);c&&r.push(c)}else{let c=this._curveHelper.getSubCurve(s,e,.5*(n-o));c&&r.push(c),c=this._curveHelper.getSubCurve(s,.5*(n+o),n-i),c&&r.push(c)}return 0===r.length?null:{paths:r}}}class Lt{constructor(){this._values=[],this.extPtGap=0,this.ctrlPtGap=0,this._length=0,this._currentValue=0}isEmpty(){return 0===this._values.length}size(){return this._values.length}init(s,e,i=!0){if(this._setEmpty(),!s||0===s.length)return!1;for(let o=0;o<s.length;o++){let n=Math.abs(s[o]);i&&n<1e-7&&(n=1e-7),this._values.push(n),this._length+=n}return e&&1&s.length&&(this._length*=2),0!==this._length&&(this.ctrlPtGap=this.extPtGap=0,this._currentValue=-1,!0)}scale(s){const e=this._values?this._values.length:0;for(let i=0;i<e;++i)this._values[i]*=s;this._length*=s,this.extPtGap*=s,this.ctrlPtGap*=s}addValue(s){this._length+=s,this._values.push(s)}firstValue(){return this._values[0]}lastValue(){return this._values[this._values.length-1]}nextValue(){return this._currentValue++,this._currentValue===this._values.length&&(this._currentValue=0),this._values[this._currentValue]}reset(){this._currentValue=-1}length(){return this._length}_setEmpty(){this.extPtGap=this.ctrlPtGap=this._length=0,this._currentValue=-1,this._values.length=0}}var x,f;(f=x||(x={}))[f.FAIL=0]="FAIL",f[f.END=1]="END",f[f.CONTINUE=2]="CONTINUE";class V{constructor(){this.reset()}reset(){this.segment=-1,this.segmentLength=0,this.abscissa=0,this.isPathEnd=!1,this.isPartEnd=!1}isValid(){return-1!==this.segment}copyTo(s){s.segment=this.segment,s.segmentLength=this.segmentLength,s.abscissa=this.abscissa,s.isPathEnd=this.isPathEnd,s.isPartEnd=this.isPartEnd}}class q extends I{constructor(s=0,e=!1){super(s,e),this._tolerance=xt,this._currentPosition=new V}updateTolerance(s){this._tolerance=xt*s}init(s,e,i=!0){return i?(this._patternLength=e.length(),this._partExtPtGap=e.extPtGap,this._partCtrlPtGap=e.ctrlPtGap):(this._patternLength=0,this._partExtPtGap=0,this._partCtrlPtGap=0),this._currentPosition.reset(),this._partSegCount=0,this._path=s,this._seg=-1,this._setPosAtNextPart()}curPositionIsValid(){return this._currentPosition.isValid()}nextPosition(s,e=x.FAIL){const i=new V;return!!this._nextPosition(s,i,null,e)&&(i.copyTo(this._currentPosition),!0)}curPointAndAngle(s){s.pt=this._getPoint(this._currentPosition);const[e,i]=this._getAngle(this._currentPosition);s.ca=e,s.sa=i}nextPointAndAngle(s,e,i=x.FAIL){const o=new V;if(!this._nextPosition(s,o,null,i))return!1;o.copyTo(this._currentPosition),e.pt=this._getPoint(o);const[n,r]=this._getAngle(o);return e.ca=n,e.sa=r,!0}nextCurve(s){if(0===s)return null;const e=[],i=new V;return this._nextPosition(s,i,e,x.END)?(i.copyTo(this._currentPosition),e):null}isPathEnd(){return this._currentPosition.isPathEnd}getPathEnd(){if(-1===this._currentPosition.segment)throw new Error("missing segment");return this._path[this._currentPosition.segment+1]}_nextPosition(s,e,i,o){if(this._currentPosition.isPathEnd)return!1;let n=this._currentPosition.abscissa;for(this._currentPosition.segmentLength>0&&(n/=this._currentPosition.segmentLength),this._currentPosition.copyTo(e);e.abscissa+s*this._partLengthRatio>e.segmentLength+this._tolerance;){if(i){if(0===i.length)if(0===n){const c=this._path[e.segment];i.push([c[0],c[1]])}else i.push(this.getSegCoord2D(this._path,e.segment,n));const r=this._path[e.segment+1];i.push([r[0],r[1]])}if(n=0,s-=(e.segmentLength-e.abscissa)/this._partLengthRatio,this._partSegCount)e.segment=this._nextSegment(),e.segmentLength=this.calculateSegLength(this._path,e.segment),e.abscissa=0,this._partSegCount--;else{if(!this._setPosAtNextPart())return o!==x.FAIL&&(e.segmentLength=this.calculateSegLength(this._path,e.segment),e.isPartEnd=!0,o===x.END?(e.abscissa=e.segmentLength,e.isPathEnd=!0):e.abscissa=e.segmentLength+s,!0);this._currentPosition.copyTo(e)}}if(e.abscissa+=s*this._partLengthRatio,i){if(0===i.length)if(0===n){const c=this._path[e.segment];i.push([c[0],c[1]])}else i.push(this.getSegCoord2D(this._path,e.segment,n));const r=e.abscissa/e.segmentLength;if(1===r){const c=this._path[e.segment+1];i.push([c[0],c[1]])}else i.push(this.getSegCoord2D(this._path,e.segment,r))}return this._partSegCount||Math.abs(e.abscissa-e.segmentLength)<this._tolerance&&(e.isPathEnd=this._partIsLast,e.isPartEnd=!0),!0}_getPoint(s){if(-1===s.segment)throw new Error("missing segment");return this.getSegCoord2D(this._path,s.segment,s.segmentLength<=0?0:s.abscissa/s.segmentLength)}_getAngle(s){if(-1===s.segment)throw new Error("missing segment");return this.getSegAngleCS(this._path,s.segment,s.segmentLength<=0?0:s.abscissa/s.segmentLength)}_setPosAtNextPart(){for(;this._partSegCount;)this._hasNextSegment()&&this._nextSegment(),this._partSegCount--;if(!this._hasNextSegment())return!1;for(this._partLength=0,this._partIsLast=!0,this._partSegCount=0;this._hasNextSegment();)if(this._partLength+=this.calculateSegLength(this._path,this._nextSegment()),this._partSegCount++,1===(0,Q.zv)(this._path[this._getEndPointIndex()])){this._partIsLast=!this._hasNextSegment();break}let s=this._partSegCount;for(;s;)this._previousSegment(),--s;this._currentPosition.segment=this._nextSegment(),this._currentPosition.segmentLength=this.calculateSegLength(this._path,this._currentPosition.segment),this._currentPosition.abscissa=0,this._currentPosition.isPathEnd=this._currentPosition.isPartEnd=!1,--this._partSegCount;const e=this._getStartPointIndex();this._ctrlPtBegin=1===(0,Q.zv)(this._path[e]);let i=e+this._partSegCount+1;if(i>=this._path.length&&(i=0),this._ctrlPtEnd=1===(0,Q.zv)(this._path[i]),this._patternLength>0){const o=this._ctrlPtBegin?this._partCtrlPtGap:this._partExtPtGap,n=this._ctrlPtEnd?this._partCtrlPtGap:this._partExtPtGap;let r=Math.round((this._partLength-(o+n))/this._patternLength);r<=0&&(r=o+n>0?0:1),this._partLengthRatio=this._partLength/(o+n+r*this._patternLength),this._partLengthRatio<.01&&(this._partLengthRatio=1)}else this._partLengthRatio=1;return!0}_hasNextSegment(){return this._seg<this._path.length-2}_previousSegment(){return--this._seg}_nextSegment(){return++this._seg}_getStartPointIndex(){return this._seg}_getEndPointIndex(){return this._seg+1}}let k=(()=>{class f{static local(){return null===f.instance&&(f.instance=new f),f.instance}execute(e,i,o,n){return new D(e,i,o)}}return f.instance=null,f})();class D extends Q.zY{constructor(s,e,i){var o,n;super(s,!0,!0),this._walker=new q,this._walker.updateTolerance(i),this._endings=e.lineDashEnding,this._customDashPos=-(null!=(o=e.offsetAlongLine)?o:0)*i,this._offsetAtEnd=(null!=(n=e.customEndingOffset)?n:0)*i,this._pattern=new Lt,this._pattern.init(e.dashTemplate,!0),this._pattern.scale(i)}processPath(s){if(0===this._pattern.length())return this.iteratePath=!1,{paths:[s]};if(!this.iteratePath){let o=!0;switch(this._endings){case S.sj.HalfPattern:case S.sj.HalfGap:default:this._pattern.extPtGap=0;break;case S.sj.FullPattern:this.isClosed||(this._pattern.extPtGap=.5*this._pattern.firstValue());break;case S.sj.FullGap:this.isClosed||(this._pattern.extPtGap=.5*this._pattern.lastValue());break;case S.sj.NoConstraint:this.isClosed||(o=!1);break;case S.sj.Custom:this.isClosed||(this._pattern.extPtGap=.5*this._offsetAtEnd)}const n=this._walker.calculatePathLength(s);if(this._pattern.isEmpty()||n<.1*this._pattern.length())return{paths:[s]};if(!this._walker.init(s,this._pattern,o))return{paths:[s]}}let e;if(this.iteratePath)e=this._pattern.nextValue();else{let o;switch(this._endings){case S.sj.HalfPattern:default:o=.5*this._pattern.firstValue();break;case S.sj.HalfGap:o=.5*-this._pattern.lastValue();break;case S.sj.FullGap:o=-this._pattern.lastValue();break;case S.sj.FullPattern:o=0;break;case S.sj.NoConstraint:case S.sj.Custom:o=-this._customDashPos}let n=o/this._pattern.length();n-=Math.floor(n),o=n*this._pattern.length(),this._pattern.reset(),e=this._pattern.nextValue();let r=!1;for(;o>=e;)o-=e,e=this._pattern.nextValue(),r=!r;e-=o,r?(this._walker.nextPosition(e),e=this._pattern.nextValue()):this.isClosed&&(this._firstCurve=this._walker.nextCurve(e),e=this._pattern.nextValue(),this._walker.nextPosition(e),e=this._pattern.nextValue())}let i=this._walker.nextCurve(e);return i?this._walker.isPathEnd()?(this.iteratePath=!1,this._firstCurve&&(this._firstCurve.splice(0,1),U.mergePath(i,this._firstCurve),this._firstCurve=null)):(e=this._pattern.nextValue(),!this._walker.nextPosition(e)||this._walker.isPathEnd()?(this.iteratePath=!1,this._firstCurve&&(i=this._firstCurve,this._firstCurve=null)):this.iteratePath=!0):(this.iteratePath=!1,i=this._firstCurve,this._firstCurve=null),{paths:[i]}}}let F=(()=>{class f{static local(){return null===f.instance&&(f.instance=new f),f.instance}execute(e,i,o,n){return new K(e,i,o)}}return f.instance=null,f})();class K{constructor(s,e,i){switch(this._inputGeometries=s,this._curveHelper=new I,this._width=(void 0!==e.width?e.width:2)*i,e.method){case S.$y.Mitered:default:this._method=S.id.Mitered;break;case S.$y.Bevelled:this._method=S.id.Bevelled;break;case S.$y.Rounded:case S.$y.TrueBuffer:this._method=S.id.Rounded;break;case S.$y.Square:this._method=S.id.Square}this._option=e.option,this._offsetFlattenError=xt*i}next(){let s=this._inputGeometries.next();for(;s;){if((0,H.YX)(s)&&this._width>0){if(Math.min(s.xmax-s.xmin,s.ymax-s.ymin)-2*this._width<0)return s;const e=[];return e.push([[s.xmin,s.ymin],[s.xmin,s.ymax],[s.xmax,s.ymax],[s.xmax,s.ymin],[s.xmin,s.ymin]]),e.push([[s.xmin+this._width,s.ymin+this._width],[s.xmax-this._width,s.ymin+this._width],[s.xmax-this._width,s.ymax-this._width],[s.xmin+this._width,s.ymax-this._width],[s.xmin+this._width,s.ymin+this._width]]),{rings:e}}if((0,H.oU)(s)&&this._width>0){const e=[];for(const i of s.rings){const o=this._curveHelper.calculatePathLength(i),n=this._curveHelper.offset(i,this._width,this._method,4,this._offsetFlattenError);n&&(o<0&&n.reverse(),e.push(n))}if(e.length)return{rings:e}}s=this._inputGeometries.next()}return null}}let et=(()=>{class f{static local(){return null===f.instance&&(f.instance=new f),f.instance}execute(e,i,o,n){return new gt(e,i,o)}}return f.instance=null,f})();class gt extends Q.zY{constructor(s,e,i){super(s,!1,!0),this._curveHelper=new I,this._length=(void 0!==e.length?e.length:20)*i,this._angle=void 0!==e.angle?e.angle:225,this._position=void 0!==e.position?e.position:50,this._length<0&&(this._length=-this._length),this._position<20&&(this._position=20),this._position>80&&(this._position=80),this._mirror=!1}processPath(s){if(this._curveHelper.isEmpty(s,!1))return null;const e=s[0],i=s[s.length-1];this._curveHelper.normalize([i[0]-e[0],i[1]-e[1]]);const n=[e[0]+(i[0]-e[0])*this._position/100,e[1]+(i[1]-e[1])*this._position/100],r=Math.cos((90-this._angle)/180*Math.PI);let c=Math.sin((90-this._angle)/180*Math.PI);return this._mirror&&(c=-c),this._mirror=!this._mirror,{paths:[[e,[n[0]-this._length/2*r,n[1]-this._length/2*c],[n[0]+this._length/2*r,n[1]+this._length/2*c],i]]}}}let J=(()=>{class f{static local(){return null===f.instance&&(f.instance=new f),f.instance}execute(e,i,o,n){return new a(e,i,o)}}return f.instance=null,f})();class a{constructor(s,e,i){this._inputGeometries=s,this._offsetX=void 0!==e.offsetX?e.offsetX*i:0,this._offsetY=void 0!==e.offsetY?-e.offsetY*i:0}next(){let s=this._inputGeometries.next();for(;s;){if((0,H.YX)(s))return{xmin:s.xmin+this._offsetX,xmax:s.xmax+this._offsetX,ymin:s.ymin+this._offsetY,ymax:s.ymax+this._offsetY};if((0,H.oU)(s)){const e=(0,ut.d9)(s);return this._moveMultipath(e.rings,this._offsetX,this._offsetY),e}if((0,H.l9)(s)){const e=(0,ut.d9)(s);return this._moveMultipath(e.paths,this._offsetX,this._offsetY),e}if((0,H.aW)(s)){const e=(0,ut.d9)(s);return this._movePath(e.points,this._offsetX,this._offsetY),e}if((0,H.wp)(s))return{x:s.x+this._offsetX,y:s.y+this._offsetY};s=this._inputGeometries.next()}return null}_moveMultipath(s,e,i){if(s)for(const o of s)this._movePath(o,e,i)}_movePath(s,e,i){if(s)for(const o of s)o[0]+=e,o[1]+=i}}let _=(()=>{class f{static local(){return null===f.instance&&(f.instance=new f),f.instance}execute(e,i,o,n){return new b(e,i,o)}}return f.instance=null,f})();class b{constructor(s,e,i){var o;this._inputGeometries=s,this._curveHelper=new I,this._offset=(null!=(o=e.offset)?o:1)*i,this._method=e.method,this._option=e.option,this._offsetFlattenError=xt*i}next(){let s=this._inputGeometries.next();for(;s;){if(0===this._offset)return s;if((0,H.YX)(s)){if(this._method===S.id.Rounded&&this._offset>0){const i=this._curveHelper.offset([[s.xmin,s.ymin],[s.xmin,s.ymax],[s.xmax,s.ymax],[s.xmax,s.ymin],[s.xmin,s.ymin]],-this._offset,this._method,4,this._offsetFlattenError);return i?{rings:[i]}:null}if(Math.min(s.xmax-s.xmin,s.ymax-s.ymin)+2*this._offset>0)return{xmin:s.xmin-this._offset,xmax:s.xmax+this._offset,ymin:s.ymin-this._offset,ymax:s.ymax+this._offset}}if((0,H.oU)(s)){const e=[];for(const i of s.rings){const o=this._curveHelper.offset(i,-this._offset,this._method,4,this._offsetFlattenError);o&&e.push(o)}if(e.length)return{rings:e}}if((0,H.l9)(s)){const e=[];for(const i of s.paths){const o=this._curveHelper.offset(i,-this._offset,this._method,4,this._offsetFlattenError);o&&e.push(o)}if(e.length)return{paths:e}}s=this._inputGeometries.next()}return null}}let P=(()=>{class f{static local(){return null===f.instance&&(f.instance=new f),f.instance}execute(e,i,o,n){return new v(e,i,o)}}return f.instance=null,f})();class v{constructor(s,e,i){this._inputGeometries=s,this._reverse=void 0===e.reverse||e.reverse}next(){let s=this._inputGeometries.next();for(;s;){if(!this._reverse)return s;if((0,H.l9)(s)){const e=(0,ut.d9)(s);return(0,Q.ov)(e.paths),e}s=this._inputGeometries.next()}return null}}var G=R(65401),L=R(32442);let N=(()=>{class f{static local(){return null===f.instance&&(f.instance=new f),f.instance}execute(e,i,o,n){return new rt(e,i,o)}}return f.instance=null,f})();class rt{constructor(s,e,i){this._inputGeometries=s,this._rotateAngle=void 0!==e.angle?e.angle*Math.PI/180:0}next(){let s=this._inputGeometries.next();for(;s;){if(0===this._rotateAngle)return s;const e=(0,G.Ue)();(0,L.$P)(e,s);const i=(e[2]+e[0])/2,o=(e[3]+e[1])/2;if((0,H.YX)(s)){const n={rings:[[[s.xmin,s.ymin],[s.xmin,s.ymax],[s.xmax,s.ymax],[s.xmax,s.ymin],[s.xmin,s.ymin]]]};return this._rotateMultipath(n.rings,i,o),n}if((0,H.oU)(s)){const n=(0,ut.d9)(s);return this._rotateMultipath(n.rings,i,o),n}if((0,H.l9)(s)){const n=(0,ut.d9)(s);return this._rotateMultipath(n.paths,i,o),n}if((0,H.aW)(s)){const n=(0,ut.d9)(s);return this._rotatePath(n.points,i,o),n}if((0,H.wp)(s))return s;s=this._inputGeometries.next()}return null}_rotateMultipath(s,e,i){if(s)for(const o of s)this._rotatePath(o,e,i)}_rotatePath(s,e,i){if(s){const o=Math.cos(this._rotateAngle),n=Math.sin(this._rotateAngle);for(const r of s){const c=r[0]-e,h=r[1]-i;r[0]=e+c*o-h*n,r[1]=i+c*n+h*o}}}}let lt=(()=>{class f{static local(){return null===f.instance&&(f.instance=new f),f.instance}execute(e,i,o,n){return new nt(e,i,o)}}return f.instance=null,f})();class nt{constructor(s,e,i){this._inputGeometries=s,this._xFactor=void 0!==e.xScaleFactor?e.xScaleFactor:1.15,this._yFactor=void 0!==e.yScaleFactor?e.yScaleFactor:1.15}next(){let s=this._inputGeometries.next();for(;s;){if(1===this._xFactor&&1===this._yFactor)return s;const e=(0,G.Ue)();(0,L.$P)(e,s);const i=(e[2]+e[0])/2,o=(e[3]+e[1])/2;if((0,H.YX)(s)){const n={rings:[[[s.xmin,s.ymin],[s.xmin,s.ymax],[s.xmax,s.ymax],[s.xmax,s.ymin],[s.xmin,s.ymin]]]};return this._scaleMultipath(n.rings,i,o),n}if((0,H.oU)(s)){const n=(0,ut.d9)(s);return this._scaleMultipath(n.rings,i,o),n}if((0,H.l9)(s)){const n=(0,ut.d9)(s);return this._scaleMultipath(n.paths,i,o),n}if((0,H.aW)(s)){const n=(0,ut.d9)(s);return this._scalePath(n.points,i,o),n}if((0,H.wp)(s))return s;s=this._inputGeometries.next()}return null}_scaleMultipath(s,e,i){if(s)for(const o of s)this._scalePath(o,e,i)}_scalePath(s,e,i){if(s)for(const o of s){const r=(o[1]-i)*this._yFactor;o[0]=e+(o[0]-e)*this._xFactor,o[1]=i+r}}}let at=(()=>{class f{static local(){return null===f.instance&&(f.instance=new f),f.instance}execute(e,i,o,n){return new vt(e,i,o)}}return f.instance=null,f})();class vt{constructor(s,e,i){this._inputGeometries=s,this._height=(void 0!==e.amplitude?e.amplitude:2)*i,this._period=(void 0!==e.period?e.period:3)*i,this._style=e.waveform,this._height<=0&&(this._height=Math.abs(this._height)),this._period<=0&&(this._period=Math.abs(this._period)),this._pattern=new Lt,this._pattern.addValue(this._period),this._pattern.addValue(this._period),this._walker=new q,this._walker.updateTolerance(i)}next(){let s=this._inputGeometries.next();for(;s;){if(0===this._height||0===this._period)return s;if((0,H.l9)(s)){const e=this._processGeom(s.paths);if(e.length)return{paths:e}}if((0,H.oU)(s)){const e=this._processGeom(s.rings);if(e.length)return{rings:e}}s=this._inputGeometries.next()}return null}_processGeom(s){const e=[];for(const i of s)if(this._walker.init(i,this._pattern))switch(this._style){case S.zQ.Sinus:default:e.push(this._constructCurve(i,!1));break;case S.zQ.Square:e.push(this._constructSquare(i));break;case S.zQ.Triangle:e.push(this._constructTriangle(i));break;case S.zQ.Random:e.push(this._constructCurve(i,!0))}else e.push(i);return e}_constructCurve(s,e){const i=new U,o=this._walker.calculatePathLength(s);let n=Math.round(o/this._period);0===n&&(n=1);const h=this._period/16,u=1/(16*n+1),p=2*Math.PI*o/(o/n),g=2*Math.PI*Math.random(),A=2*Math.PI*Math.random(),T=2*Math.PI*Math.random(),O=.75-Math.random()/2,B=.75-Math.random()/2,tt={};this._walker.curPointAndAngle(tt),i.startPath(tt.pt);let At=0;for(;;){if(!this._walker.nextPointAndAngle(h,tt)){i.lineTo(s[s.length-1]);break}{const Et=At;let St;if(At+=u,e){const Mt=this._height/2*(1+.3*Math.sin(O*p*Et+g));St=Mt*Math.sin(p*Et+A),St+=Mt*Math.sin(B*p*Et+T),St/=2}else St=.5*this._height*Math.sin(.5*p*Et);i.lineTo([tt.pt[0]-St*tt.sa,tt.pt[1]+St*tt.ca])}}return i.path()}_constructSquare(s){const e=new U,i=this._walker.calculatePathLength(s);Math.round(i/this._period);let o=!0;for(;;){let n=!1;if(this._walker.curPositionIsValid()){const r={};this._walker.curPointAndAngle(r);const c={};if(this._walker.nextPointAndAngle(this._period,c)){const h={};this._walker.nextPointAndAngle(this._period,h)&&(o?(e.startPath(r.pt),o=!1):e.lineTo(r.pt),e.lineTo([r.pt[0]-this._height/2*r.sa,r.pt[1]+this._height/2*r.ca]),e.lineTo([c.pt[0]-this._height/2*c.sa,c.pt[1]+this._height/2*c.ca]),e.lineTo([c.pt[0]+this._height/2*c.sa,c.pt[1]-this._height/2*c.ca]),e.lineTo([h.pt[0]+this._height/2*h.sa,h.pt[1]-this._height/2*h.ca]),n=!0)}}if(!n){e.lineTo(this._walker.getPathEnd());break}}return e.path()}_constructTriangle(s){const e=new U,i=this._walker.calculatePathLength(s);Math.round(i/this._period);let o=!0;for(;;){let n=!1;if(this._walker.curPositionIsValid()){const r={};this._walker.curPointAndAngle(r);const c={};if(this._walker.nextPointAndAngle(this._period/2,c)){const h={};this._walker.nextPointAndAngle(this._period,h)&&(this._walker.nextPosition(this._period/2)&&(o?(e.startPath(r.pt),o=!1):e.lineTo(r.pt),e.lineTo([c.pt[0]-this._height/2*c.sa,c.pt[1]+this._height/2*c.ca]),e.lineTo([h.pt[0]+this._height/2*h.sa,h.pt[1]-this._height/2*h.ca])),n=!0)}}if(!n){e.lineTo(this._walker.getPathEnd());break}}return e.path()}}let Tt=(()=>{class f{static local(){return null===f.instance&&(f.instance=new f),f.instance}execute(e,i,o,n){return new z(e,i,o)}}return f.instance=null,f})();class z extends Q.v1{constructor(s,e,i){var o;super(s,!0,!0),this._geometryWalker=new q,this._geometryWalker.updateTolerance(i),this._angleToLine=null==(o=e.angleToLine)||o,this._offset=(e.offset?e.offset:0)*i,this._originalEndings=e.endings,this._offsetAtEnd=(e.customEndingOffset?e.customEndingOffset:0)*i,this._position=-(e.offsetAlongLine?e.offsetAlongLine:0)*i,this._pattern=new Lt,this._pattern.init(e.placementTemplate,!1),this._pattern.scale(i),this._endings=this._originalEndings}processPath(s){if(this._pattern.isEmpty())return null;let e;if(this.iteratePath)e=this._pattern.nextValue();else{this._endings=this._originalEndings===S.JS.WithFullGap&&this.isClosed?S.JS.WithMarkers:this._originalEndings,this._pattern.extPtGap=0;let o,n=!0;switch(this._endings){case S.JS.NoConstraint:o=-this._position,o=this._adjustPosition(o),n=!1;break;case S.JS.WithHalfGap:default:o=-this._pattern.lastValue()/2;break;case S.JS.WithFullGap:o=-this._pattern.lastValue(),this._pattern.extPtGap=this._pattern.lastValue();break;case S.JS.WithMarkers:o=0;break;case S.JS.Custom:o=-this._position,o=this._adjustPosition(o),this._pattern.extPtGap=.5*this._offsetAtEnd}if(!this._geometryWalker.init(s,this._pattern,n))return null;this._pattern.reset();let r=0;for(;o>r;)o-=r,r=this._pattern.nextValue();r-=o,e=r,this.iteratePath=!0}const i={};return this._geometryWalker.nextPointAndAngle(e,i)?this._endings===S.JS.WithFullGap&&this._geometryWalker.isPathEnd()?(this.iteratePath=!1,null):this._endings===S.JS.WithMarkers&&this._geometryWalker.isPathEnd()&&(this.iteratePath=!1,this.isClosed)?null:(this.internalPlacement.setTranslate(i.pt[0]-this._offset*i.sa,i.pt[1]+this._offset*i.ca),this._angleToLine&&this.internalPlacement.setRotateCS(i.ca,i.sa),this.internalPlacement):(this.iteratePath=!1,null)}_adjustPosition(s){let e=s/this._pattern.length();return e-=Math.floor(e),e*this._pattern.length()}}let l=(()=>{class f{static local(){return null===f.instance&&(f.instance=new f),f.instance}execute(e,i,o,n){return new m(e,i,o)}}return f.instance=null,f})();class m extends Q.v1{constructor(s,e,i){super(s,!1,!0),this._curveHelper=new I,this._angleToLine=void 0===e.angleToLine||e.angleToLine,this._offset=void 0!==e.offset?e.offset*i:0,this._type=e.extremityPlacement,this._position=void 0!==e.offsetAlongLine?e.offsetAlongLine*i:0,this._beginProcessed=!1}processPath(s){let e;switch(this._type){case S.Tx.Both:default:this._beginProcessed?(e=this._atExtremities(s,this._position,!1),this._beginProcessed=!1,this.iteratePath=!1):(e=this._atExtremities(s,this._position,!0),this._beginProcessed=!0,this.iteratePath=!0);break;case S.Tx.JustBegin:e=this._atExtremities(s,this._position,!0);break;case S.Tx.JustEnd:e=this._atExtremities(s,this._position,!1);case S.Tx.None:}return e}_atExtremities(s,e,i){const o=s.length;if(o<2)return null;const r=i?o:-1,c=i?1:-1;let h,u=0,p=i?s[0]:s[o-1];for(let g=i?1:o-2;g!==r;g+=c){h=p,p=s[g];const A=this._curveHelper.calculateLength(h,p);if(u+A>e){const T=(e-u)/A,[O,B]=this._curveHelper.getAngleCS(h,p,T),tt=(0,Q.XV)(h,p,T);return this.internalPlacement.setTranslate(tt[0]-this._offset*B,tt[1]+this._offset*O),this._angleToLine&&this.internalPlacement.setRotateCS(-O,-B),this.internalPlacement}u+=A}return null}}let d=(()=>{class f{static local(){return null===f.instance&&(f.instance=new f),f.instance}execute(e,i,o,n){return new M(e,i,o)}}return f.instance=null,f})();class M extends Q.v1{constructor(s,e,i){super(s,!0,!0),this._walker=new q,this._walker.updateTolerance(i),this._angleToLine=void 0===e.angleToLine||e.angleToLine,this._offset=void 0!==e.offset?e.offset*i:0,this._beginGap=void 0!==e.beginPosition?e.beginPosition*i:0,this._endGap=void 0!==e.endPosition?e.endPosition*i:0,this._flipFirst=void 0===e.flipFirst||e.flipFirst,this._pattern=new Lt,this._pattern.init(e.positionArray,!1,!1),this._subPathLen=0,this._posCount=this._pattern.size(),this._isFirst=!0,this._prevPos=0}processPath(s){if(this._pattern.isEmpty())return null;let e;if(this.iteratePath){const c=this._pattern.nextValue()*this._subPathLen,h=this._beginGap+c;e=h-this._prevPos,this._prevPos=h}else{if(this._posCount=this._pattern.size(),this._isFirst=!0,this._prevPos=0,this._subPathLen=this._walker.calculatePathLength(s)-this._beginGap-this._endGap,this._subPathLen<0)return this.iteratePath=!1,null;if(!this._walker.init(s,this._pattern,!1))return null;this._pattern.reset();const c=this._pattern.nextValue()*this._subPathLen,h=this._beginGap+c;e=h-this._prevPos,this._prevPos=h,this.iteratePath=!0}const i={};if(!this._walker.nextPointAndAngle(e,i,x.END))return this.iteratePath=!1,null;let n,r;return this.internalPlacement.setTranslate(i.pt[0]-this._offset*i.sa,i.pt[1]+this._offset*i.ca),this._angleToLine?(n=i.ca,r=i.sa):(n=1,r=0),this._isFirst&&this._flipFirst&&(n=-n,r=-r),this.internalPlacement.setRotateCS(n,r),this._isFirst=!1,this._posCount--,0===this._posCount&&(this.iteratePath=!1),this.internalPlacement}}var E=R(4619),y=R(97373);let C=(()=>{class f{static local(){return null===f.instance&&(f.instance=new f),f.instance}execute(e,i,o,n){return new X(e,i,o,n)}}return f.instance=null,f})();class X{constructor(s,e,i,o){var n,r,c,h,u,p,g,A,T;if(this._xMin=0,this._xMax=0,this._yMin=0,this._yMax=0,this._currentX=0,this._currentY=0,this._stepX=Math.abs(null!=(n=e.stepX)?n:16)*i,this._stepY=Math.abs(null!=(r=e.stepY)?r:16)*i,0!==this._stepX&&0!==this._stepY&&s&&function w(f){return void 0!==f.rings}(s)&&s.rings){if(this._gridType=null!=(c=e.gridType)?c:S.bj.Fixed,this._gridType===S.bj.Random){const O=null!=(h=e.seed)?h:13;this._randomLCG=new E.Z(1*O),this._randomness=(null!=(u=e.randomness)?u:100)/100,this._gridAngle=0,this._shiftOddRows=!1,this._cosAngle=1,this._sinAngle=0,this._offsetX=0,this._offsetY=0}else{if(this._randomness=0,this._gridAngle=null!=(p=e.gridAngle)?p:0,this._shiftOddRows=null!=(g=e.shiftOddRows)&&g,this._offsetX=(null!=(A=e.offsetX)?A:0)*i,this._offsetY=(null!=(T=e.offsetY)?T:0)*i,this._cosAngle=Math.cos(this._gridAngle/180*Math.PI),this._sinAngle=-Math.sin(this._gridAngle/180*Math.PI),this._stepX)if(this._offsetX<0)for(;this._offsetX<-.5*this._stepX;)this._offsetX+=this._stepX;else for(;this._offsetX>=.5*this._stepX;)this._offsetX-=this._stepX;if(this._stepY)if(this._offsetY<0)for(;this._offsetY<-.5*this._stepY;)this._offsetY+=this._stepY;else for(;this._offsetY>=.5*this._stepY;)this._offsetY-=this._stepY}this._graphicOriginX=0,this._graphicOriginY=0,this._internalPlacement=new y.u,this._calculateMinMax(s),this._geometry=s}}next(){return this._geometry?this._nextInside():null}_calculateMinMax(s){let e,i,o,n,r,c,h,u;this._xMin=0,this._xMax=0,this._yMin=0,this._yMax=0,r=c=Number.MAX_VALUE,h=u=-Number.MAX_VALUE;for(const p of s.rings){const g=p?p.length:0;for(let A=0;A<g;++A)e=p[A][0]-this._graphicOriginX-this._offsetX,i=p[A][1]-this._graphicOriginY-this._offsetY,o=this._cosAngle*e-this._sinAngle*i,n=this._sinAngle*e+this._cosAngle*i,r=Math.min(r,o),h=Math.max(h,o),c=Math.min(c,n),u=Math.max(u,n)}r+=this._graphicOriginX,h+=this._graphicOriginX,c+=this._graphicOriginY,u+=this._graphicOriginY,this._xMin=Math.round(r/this._stepX),this._xMax=Math.round(h/this._stepX),this._yMin=Math.round(c/this._stepY),this._yMax=Math.round(u/this._stepY),this._currentX=this._xMax+1,this._currentY=this._yMin-1}_nextInside(){for(;;){if(this._currentX>this._xMax){if(this._currentY++,this._currentY>this._yMax)return null;this._currentX=this._xMin,this._shiftOddRows&&this._currentY%2&&this._currentX--}let s=this._currentX*this._stepX+this._offsetX;this._shiftOddRows&&this._currentY%2&&(s+=.5*this._stepX);const e=this._currentY*this._stepY+this._offsetY;let i,o;return this._currentX++,this._gridType===S.bj.Random?(i=this._graphicOriginX+s+this._stepX*this._randomness*(.5-this._randomLCG.getFloat())*2/3,o=this._graphicOriginY+e+this._stepY*this._randomness*(.5-this._randomLCG.getFloat())*2/3):(i=this._graphicOriginX+this._cosAngle*s+this._sinAngle*e,o=this._graphicOriginY-this._sinAngle*s+this._cosAngle*e),this._internalPlacement.setTranslate(i,o),this._internalPlacement}}}let $=(()=>{class f{static local(){return null===f.instance&&(f.instance=new f),f.instance}execute(e,i,o,n){return new _t(e,i,o)}}return f.instance=null,f})();class _t extends Q.v1{constructor(s,e,i){super(s,!0,!0),this._curveHelper=new I,this._angleToLine=void 0===e.angleToLine||e.angleToLine,this._offset=void 0!==e.offset?e.offset*i:0,this._relativeTo=e.relativeTo,this._position=void 0!==e.startPointOffset?e.startPointOffset*i:0,this._epsilon=.001*i}processPath(s){const e=this._position;if(this._relativeTo===S.CS.SegmentMidpoint){for(this.iteratePath||(this._segmentCount=s.length,this._curSegment=1,this.iteratePath=!0);this._curSegment<this._segmentCount;){const o=this._curSegment;this._curSegment++;const n=s[o-1],r=s[o],c=this._curveHelper.calculateLength(n,r);if(c<this._epsilon)continue;const h=.5+this._position/c,[u,p]=this._curveHelper.getAngleCS(n,r,h),g=(0,Q.XV)(n,r,h);return this.internalPlacement.setTranslate(g[0]-this._offset*p,g[1]+this._offset*u),this._angleToLine&&this.internalPlacement.setRotateCS(u,p),this.internalPlacement}return this.iteratePath=!1,null}this._relativeTo===S.CS.LineEnd&&(0,Q.hh)(s);const i=this.onLine(s,e);return this._relativeTo===S.CS.LineEnd&&(0,Q.hh)(s),i}onLine(s,e){let i,o=!1;switch(this._relativeTo){case S.CS.LineMiddle:default:i=this._curveHelper.calculatePathLength(s)/2+e;break;case S.CS.LineBeginning:i=e;break;case S.CS.LineEnd:i=e,o=!0}const n=s.length;let r,c=0,h=s[0];for(let u=1;u<n;++u){r=h,h=s[u];const p=this._curveHelper.calculateLength(r,h);if(c+p>i){const g=(i-c)/p,[A,T]=this._curveHelper.getAngleCS(r,h,g),O=(0,Q.XV)(r,h,g),B=o?-this._offset:this._offset;return this.internalPlacement.setTranslate(O[0]-B*T,O[1]+B*A),this._angleToLine&&(o?this.internalPlacement.setRotateCS(-A,-T):this.internalPlacement.setRotateCS(A,T)),this.internalPlacement}c+=p}return null}}let ct=(()=>{class f{static local(){return null===f.instance&&(f.instance=new f),f.instance}execute(e,i,o,n){return new it(e,i,o)}}return f.instance=null,f})();class it extends Q.v1{constructor(s,e,i){super(s,!0,!0),this._curveHelper=new I,this._angleToLine=void 0===e.angleToLine||e.angleToLine,this._offset=void 0!==e.offset?e.offset*i:0,this._endPoints=void 0===e.placeOnEndPoints||e.placeOnEndPoints,this._controlPoints=void 0===e.placeOnControlPoints||e.placeOnControlPoints,this._regularVertices=void 0===e.placeOnRegularVertices||e.placeOnRegularVertices,this._tags=[],this._tagIterator=0}processPath(s){if(this.iteratePath||(this._preparePath(s),this.iteratePath=!0),this._tagIterator>=this._tags.length)return this._tags.length=0,this._tagIterator=0,this.iteratePath=!1,null;const e=this._tags[this._tagIterator];this._angleToLine&&this.internalPlacement.setRotate(e[2]);let i=e[0],o=e[1];if(0!==this._offset){const n=Math.cos(e[2]),r=Math.sin(e[2]);i-=this._offset*r,o+=this._offset*n}return this.internalPlacement.setTranslate(i,o),this._tagIterator++,this.internalPlacement}_preparePath(s){this._tags.length=0,this._tagIterator=0;const e=(0,Q.QK)(s),i=s.length-1;let o,n,r=0,c=0,h=0,u=0,p=0;for(;r<i;){r++,o=s[r-1],n=s[r];const g=(0,Q.zv)(o),A=(0,Q.zv)(n);(this._angleToLine||0!==this._offset)&&(u=this._curveHelper.getAngle(o,n,0)),1===r?e?(c=u,h=g):(this._endPoints||this._controlPoints&&1===g)&&this._tags.push([o[0],o[1],u]):1===g?this._controlPoints&&this._tags.push([o[0],o[1],mt(p,u)]):this._regularVertices&&this._tags.push([o[0],o[1],mt(p,u)]),(this._angleToLine||0!==this._offset)&&(p=this._curveHelper.getAngle(o,n,1)),r===i&&(e?1===A||1===h?this._controlPoints&&this._tags.push([n[0],n[1],mt(p,c)]):this._regularVertices&&this._tags.push([n[0],n[1],mt(p,c)]):(this._endPoints||this._controlPoints&&1===A)&&this._tags.push([n[0],n[1],p]))}this._tagIterator=0}}function mt(f,s){const e=Math.PI;for(;Math.abs(s-f)>e+2e-15;)s-f>e?s-=2*e:s+=2*e;return(f+s)/2}let Pt=(()=>{class f{static local(){return null===f.instance&&(f.instance=new f),f.instance}execute(e,i,o,n){return new Dt(e,i,o)}}return f.instance=null,f})();class Dt{constructor(s,e,i){this._geometry=s,this._offsetX=void 0!==e.offsetX?e.offsetX*i:0,this._offsetY=void 0!==e.offsetY?e.offsetY*i:0,this._method=void 0!==e.method?e.method:S.Lh.OnPolygon,this._internalPlacement=new y.u}next(){const s=this._geometry;return this._geometry=null,s&&function Ct(f){return void 0!==f.rings}(s)?this._polygonCenter(s):null}_polygonCenter(s){let e=!1;switch(this._method){default:{const i=(0,G.Ue)();(0,L.$P)(i,s),this._internalPlacement.setTranslate((i[2]+i[0])/2+this._offsetX,(i[3]+i[1])/2+this._offsetY),e=!0;break}}return e?this._internalPlacement:null}}function Gt(f){if(!f)return null;switch(f.type){case"CIMGeometricEffectAddControlPoints":return ht.local();case"CIMGeometricEffectArrow":return ft.local();case"CIMGeometricEffectBuffer":return st.local();case"CIMGeometricEffectControlMeasureLine":return pt.local();case"CIMGeometricEffectCut":return kt.local();case"CIMGeometricEffectDashes":return k.local();case"CIMGeometricEffectDonut":return F.local();case"CIMGeometricEffectJog":return et.local();case"CIMGeometricEffectMove":return J.local();case"CIMGeometricEffectOffset":return _.local();case"CIMGeometricEffectReverse":return P.local();case"CIMGeometricEffectRotate":return N.local();case"CIMGeometricEffectScale":return lt.local();case"CIMGeometricEffectWave":return at.local()}return null}function Ft(f){if(!f)return null;switch(f.type){case"CIMMarkerPlacementAlongLineSameSize":return Tt.local();case"CIMMarkerPlacementAtExtremities":return l.local();case"CIMMarkerPlacementAtRatioPositions":return d.local();case"CIMMarkerPlacementInsidePolygon":return C.local();case"CIMMarkerPlacementOnLine":return $.local();case"CIMMarkerPlacementOnVertices":return ct.local();case"CIMMarkerPlacementPolygonCenter":return Pt.local()}return null}},97373:(Rt,yt,R)=>{R.d(yt,{u:()=>ut});class ut{constructor(){this.setIdentity()}getAngle(){return(null==this.rz||0===this.rz&&1!==this.rz_c&&0!==this.rz_s)&&(this.rz=Math.atan2(this.rz_s,this.rz_c)),this.rz}setIdentity(){this.tx=0,this.ty=0,this.tz=0,this.s=1,this.rx=0,this.ry=0,this.rz=0,this.rz_c=1,this.rz_s=0}setTranslate(ht,bt){this.tx=ht,this.ty=bt}setTranslateZ(ht){this.tz=ht}setRotateCS(ht,bt){this.rz=void 0,this.rz_c=ht,this.rz_s=bt}setRotate(ht){this.rz=ht,this.rz_c=void 0,this.rz_s=void 0}setRotateY(ht){this.ry=ht}setScale(ht){this.s=ht}setMeasure(ht){this.m=ht}}},57052:(Rt,yt,R)=>{R.d(yt,{Z:()=>S});var ut=R(15861),H=R(84792),Q=R(26584),ht=R(10699);class S{constructor(){this._resourceMap=new Map,this._inFlightResourceMap=new Map,this.geometryEngine=null}destroy(){this._inFlightResourceMap.clear(),this._resourceMap.clear()}getResource(I){var Y;return null!=(Y=this._resourceMap.get(I))?Y:null}fetchResource(I,Y){var j=this;return(0,ut.Z)(function*(){const ot={width:0,height:0},ft=j._resourceMap,Z=ft.get(I);if(Z)return ot.width=Z.width,ot.height=Z.height,ot;let st=j._inFlightResourceMap.get(I);return st||(st=function xt(U,I){if(U.includes(";base64,")){const Y=new Image;return Y.src=U,Y.decode().then(()=>({ok:!0,value:Y})).catch(j=>(0,ht.D_)(j)?{ok:!1,error:j}:{ok:!1,error:new Q.Z("invalid-resource",`Could not fetch requested resource at ${U}`)})}return(0,H.default)(U,Wt({responseType:"image"},I)).then(Y=>({ok:!0,value:Y.data})).catch(Y=>(0,ht.D_)(Y)?{ok:!1,error:Y}:{ok:!1,error:new Q.Z("invalid-resource",`Could not fetch requested resource at ${U}`)})}(I,Y),j._inFlightResourceMap.set(I,st),st=st.then(wt=>{if(j._inFlightResourceMap.delete(I),wt.ok){ft.set(I,wt.value);const pt=wt.value;return ot.width=pt.width,ot.height=pt.height,ot}return ot}),st)})()}deleteResource(I){this._inFlightResourceMap.delete(I),this._resourceMap.delete(I)}}},89932:(Rt,yt,R)=>{R.d(yt,{Tu:()=>k,cD:()=>D,et:()=>gt,g:()=>et,uQ:()=>q,x1:()=>K,zA:()=>x});var ut=R(986),H=R(63290),Q=R(62208),ht=R(27899),bt=R(23841),S=R(65401),xt=R(32442),U=R(27105),I=R(91179),Y=R(29214),j=R(11004),ot=R(97373),ft=R(57052),Z=R(7547),st=R(31375),wt=R(68937),pt=R(61261),zt=R(39351),kt=R(25797);const It=Math.PI/180,Lt=H.Z.getLogger("esri.symbols.cim.CIMSymbolDrawHelper");class x{constructor(a){this._t=a}static createIdentity(){return new x([1,0,0,0,1,0])}clone(){return new x(this._t.slice())}transform(a){const _=this._t;return[_[0]*a[0]+_[1]*a[1]+_[2],_[3]*a[0]+_[4]*a[1]+_[5]]}static createScale(a,_){return new x([a,0,0,0,_,0])}scale(a,_){const b=this._t;return b[0]*=a,b[1]*=a,b[2]*=a,b[3]*=_,b[4]*=_,b[5]*=_,this}scaleRatio(){return Math.sqrt(this._t[0]*this._t[0]+this._t[1]*this._t[1])}static createTranslate(a,_){return new x([0,0,a,0,0,_])}translate(a,_){const b=this._t;return b[2]+=a,b[5]+=_,this}static createRotate(a){const _=Math.cos(a),b=Math.sin(a);return new x([_,-b,0,b,_,0])}rotate(a){return x.multiply(this,x.createRotate(a),this)}static multiply(a,_,b){const P=a._t,v=_._t,L=P[1]*v[0]+P[4]*v[1],N=P[2]*v[0]+P[5]*v[1]+v[2],rt=P[0]*v[3]+P[3]*v[4],lt=P[1]*v[3]+P[4]*v[4],nt=P[2]*v[3]+P[5]*v[4]+v[5],at=b._t;return at[0]=P[0]*v[0]+P[3]*v[1],at[1]=L,at[2]=N,at[3]=rt,at[4]=lt,at[5]=nt,b}invert(){const a=this._t;let _=a[0]*a[4]-a[1]*a[3];return 0===_?new x([0,0,0,0,0,0]):(_=1/_,new x([a[4]*_,-a[1]*_,(a[1]*a[5]-a[2]*a[4])*_,-a[3]*_,a[0]*_,(a[2]*a[3]-a[0]*a[5])*_]))}}class V{constructor(a,_){this._transfos=[],this._sizeTransfos=[],this._geomUnitsPerPoint=1,this._placementPool=new ht.Z(ot.u,null,null,100),this._earlyReturn=!1,this._mapRotation=0,this._resourceManager=a||new ft.Z,this._transfos.push(_||x.createIdentity()),this._sizeTransfos.push(_?_.scaleRatio():1)}setTransform(a,_){this._transfos=[a||x.createIdentity()],this._sizeTransfos=[_||(a?a.scaleRatio():1)]}setGeomUnitsPerPoint(a){this._geomUnitsPerPoint=a}transformPt(a){return this._transfos[this._transfos.length-1].transform(a)}transformSize(a){return a*this._sizeTransfos[this._sizeTransfos.length-1]}reverseTransformPt(a){return this._transfos[this._transfos.length-1].invert().transform(a)}reverseTransformSize(a){return a/this._sizeTransfos[this._sizeTransfos.length-1]}geomUnitsPerPoint(){return this.isEmbedded()?1:this._geomUnitsPerPoint}isEmbedded(){return this._transfos.length>1}back(){return this._transfos[this._transfos.length-1]}push(a,_){const b=_?a.scaleRatio():1;x.multiply(a,this.back(),a),this._transfos.push(a),this._sizeTransfos.push(this._sizeTransfos[this._sizeTransfos.length-1]*b)}pop(){this._transfos.splice(-1,1),this._sizeTransfos.splice(-1,1)}drawSymbol(a,_){if(a)switch(a.type){case"CIMPointSymbol":case"CIMLineSymbol":case"CIMPolygonSymbol":this.drawMultiLayerSymbol(a,_);break;case"CIMTextSymbol":this.drawTextSymbol(a,_)}}drawMultiLayerSymbol(a,_){if(!a)return;const b=a.symbolLayers;if(!b)return;const P=a.effects;if(P&&P.length>0){const v=this.executeEffects(P,_);if(v){let G=v.next();for(;G;)this.drawSymbolLayers(b,G),G=v.next()}}else this.drawSymbolLayers(b,_)}executeEffects(a,_){const b=this._resourceManager.geometryEngine;let P=new Y.M(_);for(const v of a){const G=(0,j.h)(v);G&&(P=G.execute(P,v,this.geomUnitsPerPoint(),b))}return P}drawSymbolLayers(a,_){let b=a.length;for(;b--;){const P=a[b];if(!P||!1===P.enable)continue;const v=P.effects;if(v&&v.length>0){const G=this.executeEffects(v,_);if(G){let L=null;for(;(L=G.next())&&(this.drawSymbolLayer(P,L),!this._earlyReturn););}}else this.drawSymbolLayer(P,_);if(this._earlyReturn)return}}drawSymbolLayer(a,_){switch(a.type){case"CIMSolidFill":this.drawSolidFill(_,a.color);break;case"CIMHatchFill":this.drawHatchFill(_,a);break;case"CIMPictureFill":this.drawPictureFill(_,a);break;case"CIMGradientFill":this.drawGradientFill(_,a);break;case"CIMSolidStroke":this.drawSolidStroke(_,a.color,a.width,a.capStyle,a.joinStyle,a.miterLimit);break;case"CIMPictureStroke":this.drawPictureStroke(_,a);break;case"CIMGradientStroke":this.drawGradientStroke(_,a);break;case"CIMCharacterMarker":case"CIMPictureMarker":case"CIMVectorMarker":this.drawMarkerLayer(a,_)}}drawHatchFill(a,_){const b=this._buildHatchPolyline(_,a,this.geomUnitsPerPoint());b&&(this.pushClipPath(a),this.drawMultiLayerSymbol(_.lineSymbol,b),this.popClipPath())}drawPictureFill(a,_){}drawGradientFill(a,_){}drawPictureStroke(a,_){}drawGradientStroke(a,_){}drawMarkerLayer(a,_){const b=a.markerPlacement;if(b){const P=(0,j.W)(b);if(P){const v="CIMMarkerPlacementInsidePolygon"===b.type;v&&this.pushClipPath(_);const G=P.execute(_,b,this.geomUnitsPerPoint(),this._resourceManager.geometryEngine);if(G){let L=null;for(;(L=G.next())&&(this.drawMarker(a,L),!this._earlyReturn););}v&&this.popClipPath()}}else{const P=this._placementPool.acquire();if((0,I.wp)(_))P.tx=_.x,P.ty=_.y,this.drawMarker(a,P);else if((0,I.oU)(_))[P.tx,P.ty]=(0,U.tO)(_),this.drawMarker(a,P);else for(const v of _.points)if(P.tx=v[0],P.ty=v[1],this.drawMarker(a,P),this._earlyReturn)break;this._placementPool.release(P)}}drawMarker(a,_){switch(a.type){case"CIMCharacterMarker":case"CIMPictureMarker":this.drawPictureMarker(a,_);break;case"CIMVectorMarker":this.drawVectorMarker(a,_)}}drawPictureMarker(a,_){var l,m,d,M,E;if(!a)return;const b=this._resourceManager.getResource(a.url),P=null!=(l=a.size)?l:10;if((0,Q.Wi)(b)||P<=0)return;const v=b.width,G=b.height;if(!v||!G)return;const L=v/G,N=null!=(m=a.scaleX)?m:1,rt=x.createIdentity(),lt=a.anchorPoint;if(lt){let y=lt.x,w=lt.y;"Absolute"!==a.anchorPointUnits&&(y*=P*L*N,w*=P),rt.translate(-y,-w)}let nt=null!=(d=a.rotation)?d:0;a.rotateClockwise&&(nt=-nt),this._mapRotation&&(nt+=this._mapRotation),nt&&rt.rotate(nt*It);let at=null!=(M=a.offsetX)?M:0,vt=null!=(E=a.offsetY)?E:0;if(at||vt){if(this._mapRotation){const y=It*this._mapRotation,w=Math.cos(y),C=Math.sin(y),X=at*C+vt*w;at=at*w-vt*C,vt=X}rt.translate(at,vt)}const Tt=this.geomUnitsPerPoint();1!==Tt&&rt.scale(Tt,Tt);const z=_.getAngle();z&&rt.rotate(z),rt.translate(_.tx,_.ty),this.push(rt,!1),this.drawImage(a.url,P,a.scaleX),this.pop()}drawVectorMarker(a,_){var z,l,m,d;if(!a)return;const b=a.markerGraphics;if(!b)return;const P=null!=(z=a.size)?z:10,v=a.frame,G=v?v.ymax-v.ymin:0,L=P&&G?P/G:1,N=x.createIdentity();v&&N.translate(.5*-(v.xmax+v.xmin),.5*-(v.ymax+v.ymin));const rt=a.anchorPoint;if(rt){let M=rt.x,E=rt.y;"Absolute"!==a.anchorPointUnits?v&&(M*=v.xmax-v.xmin,E*=v.ymax-v.ymin):(M/=L,E/=L),N.translate(-M,-E)}1!==L&&N.scale(L,L);let lt=null!=(l=a.rotation)?l:0;a.rotateClockwise&&(lt=-lt),this._mapRotation&&(lt+=this._mapRotation),lt&&N.rotate(lt*It);let nt=null!=(m=a.offsetX)?m:0,at=null!=(d=a.offsetY)?d:0;if(nt||at){if(this._mapRotation){const M=It*this._mapRotation,E=Math.cos(M),y=Math.sin(M),w=nt*y+at*E;nt=nt*E-at*y,at=w}N.translate(nt,at)}const vt=this.geomUnitsPerPoint();1!==vt&&N.scale(vt,vt);const Tt=_.getAngle();Tt&&N.rotate(Tt),N.translate(_.tx,_.ty),this.push(N,a.scaleSymbolsProportionally);for(const M of b)if(M&&M.symbol&&M.geometry||Lt.error("Invalid marker graphic",M),this.drawSymbol(M.symbol,M.geometry),this._earlyReturn)break;this.pop()}drawTextSymbol(a,_){var N,rt,lt,nt;if(!a||!(0,I.wp)(_)||(null!=(N=a.height)?N:10)<=0)return;const b=x.createIdentity();let P=null!=(rt=a.angle)?rt:0;P=-P,P&&b.rotate(P*It);const v=null!=(lt=a.offsetX)?lt:0,G=null!=(nt=a.offsetY)?nt:0;(v||G)&&b.translate(v,G);const L=this.geomUnitsPerPoint();1!==L&&b.scale(L,L),b.translate(_.x,_.y),this.push(b,!1),this.drawText(a),this.pop()}_buildHatchPolyline(a,_,b){let P=(void 0!==a.separation?a.separation:4)*b,v=void 0!==a.rotation?a.rotation:0;if(0===P)return null;P<0&&(P=-P);let G=0;const L=.5*P;for(;G>L;)G-=P;for(;G<-L;)G+=P;const N=(0,S.Ue)();(0,xt.$P)(N,_),N[0]-=L,N[1]-=L,N[2]+=L,N[3]+=L;const rt=[[N[0],N[1]],[N[0],N[3]],[N[2],N[3]],[N[2],N[1]]];for(;v>180;)v-=180;for(;v<0;)v+=180;const lt=Math.cos(v*It),nt=Math.sin(v*It),at=-P*nt,vt=P*lt;let Tt,z,l,m;G=(void 0!==a.offsetX?a.offsetX*b:0)*nt-(void 0!==a.offsetY?a.offsetY*b:0)*lt,Tt=l=Number.MAX_VALUE,z=m=-Number.MAX_VALUE;for(const X of rt){const W=X[0],$=X[1],_t=lt*W+nt*$,ct=-nt*W+lt*$;Tt=Math.min(Tt,_t),l=Math.min(l,ct),z=Math.max(z,_t),m=Math.max(m,ct)}l=Math.floor(l/P)*P;let d=lt*Tt-nt*l-at*G/P,M=nt*Tt+lt*l-vt*G/P,E=lt*z-nt*l-at*G/P,y=nt*z+lt*l-vt*G/P;const w=1+Math.round((m-l)/P),C=[];for(let X=0;X<w;X++)d+=at,M+=vt,E+=at,y+=vt,C.push([[d,M],[E,y]]);return{paths:C}}}class q extends V{constructor(a,_){super(a,_),this.reset()}reset(){this._xmin=this._ymin=1/0,this._xmax=this._ymax=-1/0,this._clipCount=0}envelope(){return new st.Z(this._xmin,this._ymin,this._xmax-this._xmin,this._ymax-this._ymin)}bounds(){return(0,S.al)(this._xmin,this._ymin,this._xmax,this._ymax)}drawSolidFill(a){if(a&&!(this._clipCount>0))if((0,I.oU)(a))this._processPath(a.rings,0);else if((0,I.l9)(a))this._processPath(a.paths,0);else if((0,I.YX)(a)){const _=F(a);_&&this._processPath(_.rings,0)}else console.error("drawSolidFill Unexpected geometry type!")}drawSolidStroke(a,_,b){if(!a||this._clipCount>0)return;const P=.5*this.transformSize(b);if((0,I.oU)(a))this._processPath(a.rings,P);else if((0,I.l9)(a))this._processPath(a.paths,P);else if((0,I.YX)(a)){const v=F(a);v&&this._processPath(v.rings,P)}else console.error("drawSolidStroke unexpected geometry type!")}pushClipPath(a){this.drawSolidFill(a),++this._clipCount}popClipPath(){--this._clipCount}drawImage(a,_,b){let P=b*_,v=_;const G=this._resourceManager.getResource(a);!_&&(0,Q.pC)(G)&&(P=b*G.width,v=G.height),this._merge(this.transformPt([-P/2,-v/2]),0),this._merge(this.transformPt([-P/2,v/2]),0),this._merge(this.transformPt([P/2,-v/2]),0),this._merge(this.transformPt([P/2,v/2]),0)}drawText(a){this._textRasterizer||(this._textRasterizer=new wt.Z)}_processPath(a,_){if(a)for(const b of a){const P=b?b.length:0;if(P>1){this._merge(this.transformPt(b[0]),_);for(let v=1;v<P;++v)this._merge(this.transformPt(b[v]),_)}}}_merge(a,_){a[0]-_<this._xmin&&(this._xmin=a[0]-_),a[0]+_>this._xmax&&(this._xmax=a[0]+_),a[1]-_<this._ymin&&(this._ymin=a[1]-_),a[1]+_>this._ymax&&(this._ymax=a[1]+_)}}class k extends V{constructor(){super(...arguments),this._searchPoint=[0,0],this._searchDistPoint=0}hitTest(a,_,b,P,v,G){const L=G*(0,bt.F2)(1);return this.setTransform(),this.setGeomUnitsPerPoint(L),this._searchPoint=[(a[0]+a[2])/2,(a[1]+a[3])/2],this._searchDistPoint=(a[2]-a[0])/2/L,this._textInfo=P,this._mapRotation=_&&("CIMPointSymbol"===_.type&&"Map"!==_.angleAlignment||"CIMTextSymbol"===_.type)?v:0,this._earlyReturn=!1,this.drawSymbol(_,b),this._earlyReturn}drawSolidFill(a,_){this._hitTestFill(a)}drawHatchFill(a,_){this._hitTestFill(a)}drawPictureFill(a,_){this._hitTestFill(a)}drawGradientFill(a,_){this._hitTestFill(a)}drawSolidStroke(a,_,b,P,v,G){this._hitTestStroke(a,b)}drawPictureStroke(a,_){this._hitTestStroke(a,_.width)}drawGradientStroke(a,_){this._hitTestStroke(a,_.width)}drawMarkerLayer(a,_){a.markerPlacement&&"CIMMarkerPlacementInsidePolygon"===a.markerPlacement.type?this._hitTestFill(_):super.drawMarkerLayer(a,_)}pushClipPath(a){}popClipPath(){}drawImage(a,_,b){const P=this._resourceManager.getResource(a);if((0,Q.Wi)(P)||0===P.height||0===_)return;const v=_*this.geomUnitsPerPoint(),G=v*b*(P.width/P.height),L=this.reverseTransformPt(this._searchPoint),N=this._searchDistPoint;Math.abs(L[0])<G/2+N&&Math.abs(L[1])<v/2+N&&(this._earlyReturn=!0)}drawText(a){var Tt,z;const _=this._textInfo;if(!_)return;const b=_.get(a);if(!b)return;const{text:P,mosaicItem:v}=b;if(!v||0===v.glyphMosaicItems.length)return;const G=null!=(Tt=a.height)?Tt:10,L=gt(a.lineGapType,null!=(z=a.lineGap)?z:0,G),N=(0,ut.E)(P)[1],lt=(0,kt.Nr)(v.glyphMosaicItems,N,{scale:G/zt.Ex,angle:0,xOffset:0,yOffset:0,hAlign:K(a.horizontalAlignment),vAlign:et(a.verticalAlignment),maxLineWidth:512,lineHeight:zt.xm*Math.max(.25,Math.min(L||1,4)),decoration:a.font.decoration||"none",isCIM:!0}),nt=this.reverseTransformPt(this._searchPoint),at=nt[0],vt=nt[1];for(const l of lt.glyphs)if(at>l.xTopLeft&&at<l.xBottomRight&&vt>-l.yBottomRight&&vt<-l.yTopLeft){this._earlyReturn=!0;break}}_hitTestFill(a){let _=null;if((0,I.YX)(a))_=[[[a.xmin,a.ymin],[a.xmin,a.ymax],[a.xmax,a.ymax],[a.xmax,a.ymin],[a.xmin,a.ymin]]];else if((0,I.oU)(a))_=a.rings;else{if(!(0,I.l9)(a))return;_=a.paths}const b=this.reverseTransformPt(this._searchPoint);if(this._pointInPolygon(b,_)&&(this._earlyReturn=!0),!this._earlyReturn){const P=this.reverseTransformSize(this._searchDistPoint)*this.geomUnitsPerPoint();this._nearLine(b,_,P)&&(this._earlyReturn=!0)}}_hitTestStroke(a,_){let b=null;if((0,I.YX)(a))b=[[[a.xmin,a.ymin],[a.xmin,a.ymax],[a.xmax,a.ymax],[a.xmax,a.ymin],[a.xmin,a.ymin]]];else if((0,I.oU)(a))b=a.rings;else{if(!(0,I.l9)(a))return;b=a.paths}const P=this.reverseTransformPt(this._searchPoint),v=_*this.geomUnitsPerPoint(),G=this.reverseTransformSize(this._searchDistPoint)*this.geomUnitsPerPoint();this._nearLine(P,b,v/2+G)&&(this._earlyReturn=!0)}_pointInPolygon(a,_){let b=0;for(const P of _){const v=P.length;for(let G=1;G<v;++G){const L=P[G-1],N=P[G];L[1]>a[1]!=N[1]>a[1]&&((N[0]-L[0])*(a[1]-L[1])-(N[1]-L[1])*(a[0]-L[0])>0?b++:b--)}}return 0!==b}_nearLine(a,_,b){for(const P of _){const v=P.length;for(let G=1;G<v;++G){const L=P[G-1],N=P[G];let rt=(N[0]-L[0])*(N[0]-L[0])+(N[1]-L[1])*(N[1]-L[1]);if(0!==rt&&(rt=Math.sqrt(rt),Math.abs(((N[0]-L[0])*(a[1]-L[1])-(N[1]-L[1])*(a[0]-L[0]))/rt)<b)){const nt=((N[0]-L[0])*(a[0]-L[0])+(N[1]-L[1])*(a[1]-L[1]))/rt;if(nt>-b&&nt<rt+b)return!0}}}return!1}}class D extends V{constructor(a,_,b){super(_,b),this._ctx=a}drawSolidFill(a,_){if(!a)return;if((0,I.oU)(a))this._buildPath(a.rings,!0);else if((0,I.l9)(a))this._buildPath(a.paths,!0);else if((0,I.YX)(a))this._buildPath(F(a).rings,!0);else{if(!(0,I.aW)(a))return;console.log("CanvasDrawHelper.drawSolidFill - No implementation!")}const b=this._ctx;b.fillStyle="string"==typeof _?_:"rgba("+Math.round(_[0])+","+Math.round(_[1])+","+Math.round(_[2])+","+_[3]/255+")",b.fill("evenodd")}drawSolidStroke(a,_,b,P,v,G){if(!a||!_||0===b)return;if((0,I.oU)(a))this._buildPath(a.rings,!0);else if((0,I.l9)(a))this._buildPath(a.paths,!1);else{if(!(0,I.YX)(a))return void console.log("CanvasDrawHelper.drawSolidStroke isn't implemented!");this._buildPath(F(a).rings,!0)}const L=this._ctx;L.strokeStyle="string"==typeof _?_:"rgba("+Math.round(_[0])+","+Math.round(_[1])+","+Math.round(_[2])+","+_[3]/255+")",L.lineWidth=this.transformSize(b)+.5,this._setCapStyle(P),this._setJoinStyle(v),L.miterLimit=G,L.stroke()}pushClipPath(a){if(this._ctx.save(),(0,I.oU)(a))this._buildPath(a.rings,!0);else if((0,I.l9)(a))this._buildPath(a.paths,!0);else{if(!(0,I.YX)(a))return;this._buildPath(F(a).rings,!0)}this._ctx.clip("evenodd")}popClipPath(){this._ctx.restore()}drawImage(a,_,b){const P=this._resourceManager.getResource(a);if((0,Q.Wi)(P))return;const v=this._ctx,G=v.canvas.width,L=v.canvas.height;let N=_*b*(P.width/P.height),rt=b*_;_||(N=b*P.width,rt=b*P.height);const lt=this.transformPt([0,0]),nt=this.transformSize(N),at=this.transformSize(rt);this._ctx.drawImage(P,0,0,P.width,P.height,lt[0]-nt/2,lt[1]-at/2,Math.min(nt,G),Math.min(at,L))}drawText(a){this._textRasterizer||(this._textRasterizer=new wt.Z)}_buildPath(a,_){const b=this._ctx;if(b.beginPath(),a)for(const P of a){const v=P?P.length:0;if(v>1){let G=this.transformPt(P[0]);b.moveTo(G[0],G[1]);for(let L=1;L<v;++L)G=this.transformPt(P[L]),b.lineTo(G[0],G[1]);_&&b.closePath()}}}_setCapStyle(a){switch(a){case Z.kP.Butt:this._ctx.lineCap="butt";break;case Z.kP.Round:this._ctx.lineCap="round";break;case Z.kP.Square:this._ctx.lineCap="square"}}_setJoinStyle(a){switch(a){case Z.r4.Bevel:this._ctx.lineJoin="bevel";break;case Z.r4.Round:this._ctx.lineJoin="round";break;case Z.r4.Miter:this._ctx.lineJoin="miter"}}}const F=J=>J?{spatialReference:J.spatialReference,rings:[[[J.xmin,J.ymin],[J.xmin,J.ymax],[J.xmax,J.ymax],[J.xmax,J.ymin],[J.xmin,J.ymin]]]}:null,K=J=>{switch(J){case"Left":return pt.M7.Left;case"Right":return pt.M7.Right;case"Center":return pt.M7.Center;case"Justify":return Lt.warnOnce("Horizontal alignment 'justify' is not implemented. Falling back to 'center'."),pt.M7.Center}},et=J=>{switch(J){case"Top":return pt.TR.Top;case"Center":return pt.TR.Center;case"Bottom":return pt.TR.Bottom;case"Baseline":return pt.TR.Baseline}},gt=(J,a,_)=>{switch(J){case"ExtraLeading":return 1+a/_;case"Multiple":return a;case"Exact":return a/_}}},35909:(Rt,yt,R)=>{R.d(yt,{B$:()=>J,E0:()=>_,IV:()=>gt,U1:()=>nt,fN:()=>a,rW:()=>k});var ut=R(91558),H=R(986),Q=R(36161),ht=R(58817),bt=R(63290),S=R(21286),xt=R(62208),U=R(4619),I=R(23841),Y=R(65401),j=R(32442),ot=R(97373),ft=R(89932),Z=R(7547),st=R(80991),wt=R(86575),pt=R(39351),zt=R(25797);const kt=Math.PI,It=kt/2,x=96/72,V=Math.PI/180,q=bt.Z.getLogger("esri.symbols.cim.CIMSymbolHelper");function k(z){if(!z||!z.type)return null;let l;switch(z.type){case"cim":return z.data;case"web-style":return z;case"simple-marker":l=J.fromSimpleMarker(z);break;case"picture-marker":l=J.fromPictureMarker(z);break;case"simple-line":l=J.fromSimpleLineSymbol(z);break;case"simple-fill":l=J.fromSimpleFillSymbol(z);break;case"picture-fill":l=J.fromPictureFillSymbol(z);break;case"text":l=J.fromTextSymbol(z)}return{type:"CIMSymbolReference",symbol:l}}function D(z,l){switch(l.type){case"CIMSymbolReference":return D(z,l.symbol);case"CIMPointSymbol":case"CIMTextSymbol":z.drawSymbol(l,{x:0,y:0});break;case"CIMLineSymbol":z.drawSymbol(l,{paths:[[[0,0],[0,1]]]});break;case"CIMPolygonSymbol":z.drawSymbol(l,{rings:[[[0,0],[0,1],[0,0]]]});break;case"CIMVectorMarker":{const m=new ot.u;z.drawMarker(l,m);break}}return z.envelope()}function F(z){if(!z)return 0;switch(z.type){case"CIMMarkerPlacementAlongLineSameSize":case"CIMMarkerPlacementAlongLineRandomSize":case"CIMMarkerPlacementAtExtremities":case"CIMMarkerPlacementAtMeasuredUnits":case"CIMMarkerPlacementAtRatioPositions":case"CIMMarkerPlacementOnLine":case"CIMMarkerPlacementOnVertices":return Math.abs(z.offset);default:return 0}}function K(z){if(!z)return 0;switch(z.type){case"CIMGeometricEffectArrow":return Math.abs(.5*z.width);case"CIMGeometricEffectBuffer":return Math.abs(z.size);case"CIMGeometricEffectExtension":case"CIMGeometricEffectRadial":return Math.abs(z.length);case"CIMGeometricEffectJog":return Math.abs(.5*z.length);case"CIMGeometricEffectMove":return Math.max(Math.abs((0,st.NA)(z.offsetX)),Math.abs((0,st.NA)(z.offsetY)));case"CIMGeometricEffectOffset":case"CIMGeometricEffectOffsetTangent":return Math.abs(z.offset);case"CIMGeometricEffectRegularPolygon":return Math.abs(z.radius);case"CIMGeometricEffectRotate":case"CIMGeometricEffectScale":default:return 0;case"CIMGeometricEffectTaperedPolygon":return.5*Math.max(Math.abs(z.fromWidth),Math.abs(z.toWidth));case"CIMGeometricEffectWave":return Math.abs(z.amplitude)}}function et(z){if(!z)return 0;let l=0;for(const m of z)l+=K(m);return l}class gt{getSymbolInflateSize(l,m,d,M,E){return l||(l=[0,0,0,0]),m?this._getInflateSize(l,m,d,M,E):l}static safeSize(l){const m=Math.max(Math.abs(l[0]),Math.abs(l[2])),d=Math.max(Math.abs(l[1]),Math.abs(l[3]));return Math.sqrt(m*m+d*d)}_vectorMarkerBounds(l,m,d,M){let E=!0;const y=(0,Y.Ue)();if(m&&m.markerGraphics)for(const w of m.markerGraphics){const C=[0,0,0,0];w.geometry&&((0,j.$P)(y,w.geometry),C[0]=0,C[1]=0,C[2]=0,C[3]=0,this.getSymbolInflateSize(C,w.symbol,d,0,M),y[0]+=C[0],y[1]+=C[1],y[2]+=C[2],y[3]+=C[3],E?(l[0]=y[0],l[1]=y[1],l[2]=y[2],l[3]=y[3],E=!1):(l[0]=Math.min(l[0],y[0]),l[1]=Math.min(l[1],y[1]),l[2]=Math.max(l[2],y[2]),l[3]=Math.max(l[3],y[3])))}return l}_getInflateSize(l,m,d,M,E){if(function at(z){return void 0!==z.symbolLayers}(m)){const y=this._getLayersInflateSize(l,m.symbolLayers,d,M,E),w=et(m.effects);return w>0&&(y[0]-=w,y[1]-=w,y[2]+=w,y[3]+=w),y}return this._getTextInflatedSize(l,m,E)}_getLayersInflateSize(l,m,d,M,E){let y=!0;if(!m)return l;for(const w of m){if(!w)continue;let C=[0,0,0,0];switch(w.type){case"CIMSolidFill":case"CIMPictureFill":case"CIMHatchFill":case"CIMGradientFill":break;case"CIMSolidStroke":case"CIMPictureStroke":case"CIMGradientStroke":{const W=w;let $=W.width;$/=W.capStyle===Z.kP.Square||W.joinStyle===Z.r4.Miter?1.4142135623730951:2,C[0]=-$,C[1]=-$,C[2]=$,C[3]=$;break}case"CIMCharacterMarker":case"CIMVectorMarker":case"CIMPictureMarker":{const W=w;if("CIMVectorMarker"===w.type){const it=w;if(C=this._vectorMarkerBounds(C,it,d,E),it.frame){const mt=(it.frame.xmin+it.frame.xmax)/2,Ct=(it.frame.ymin+it.frame.ymax)/2;C[0]-=mt,C[1]-=Ct,C[2]-=mt,C[3]-=Ct;const Pt=it.size/(it.frame.ymax-it.frame.ymin);C[0]*=Pt,C[1]*=Pt,C[2]*=Pt,C[3]*=Pt}}else if("CIMPictureMarker"===w.type){const it=w,mt=d.getResource(it.url);let Ct=1;(0,xt.pC)(mt)&&mt.height&&(Ct=mt.width/mt.height);const Pt=W.size/2,Dt=W.size*Ct*it.scaleX/2;C=[-Dt,-Pt,Dt,Pt]}else{const it=W.size/2;C=[-it,-it,it,it]}if(W.anchorPoint){let it,mt;"Absolute"===W.anchorPointUnits?(it=W.anchorPoint.x,mt=W.anchorPoint.y):(it=W.anchorPoint.x*(C[2]-C[0]),mt=W.anchorPoint.y*(C[3]-C[1])),C[0]-=it,C[1]-=mt,C[2]-=it,C[3]-=mt}let $=(0,st.NA)(W.rotation);if(W.rotateClockwise&&($=-$),M&&($-=M),$){const it=V*$,mt=Math.cos(it),Ct=Math.sin(it),Pt=(0,Y.Ue)([wt.B1,wt.B1,-wt.B1,-wt.B1]);(0,Y.Ho)(Pt,[C[0]*mt-C[1]*Ct,C[0]*Ct+C[1]*mt]),(0,Y.Ho)(Pt,[C[0]*mt-C[3]*Ct,C[0]*Ct+C[3]*mt]),(0,Y.Ho)(Pt,[C[2]*mt-C[1]*Ct,C[2]*Ct+C[1]*mt]),(0,Y.Ho)(Pt,[C[2]*mt-C[3]*Ct,C[2]*Ct+C[3]*mt]),C=Pt}let _t=(0,st.NA)(W.offsetX),ct=(0,st.NA)(W.offsetY);if(M){const it=V*M,mt=Math.cos(it),Ct=Math.sin(it),Pt=_t*Ct+ct*mt;_t=_t*mt-ct*Ct,ct=Pt}C[0]+=_t,C[1]+=ct,C[2]+=_t,C[3]+=ct;const dt=F(W.markerPlacement);dt>0&&(C[0]-=dt,C[1]-=dt,C[2]+=dt,C[3]+=dt);break}}const X=et(w.effects);X>0&&(C[0]-=X,C[1]-=X,C[2]+=X,C[3]+=X),y?(l[0]=C[0],l[1]=C[1],l[2]=C[2],l[3]=C[3],y=!1):(l[0]=Math.min(l[0],C[0]),l[1]=Math.min(l[1],C[1]),l[2]=Math.max(l[2],C[2]),l[3]=Math.max(l[3],C[3]))}return l}_getTextInflatedSize(l,m,d){var _t,ct;const M=null!=(_t=m.height)?_t:10;if(l[0]=-M/2,l[1]=-M/2,l[2]=M/2,l[3]=M/2,!d)return l;const E=d.get(m);if(!E)return l;const{text:y,mosaicItem:w}=E;if(!w||0===w.glyphMosaicItems.length)return l;const C=(0,ft.et)(m.lineGapType,null!=(ct=m.lineGap)?ct:0,M),X=(0,H.E)(y)[1],$=(0,zt.Nr)(w.glyphMosaicItems,X,{scale:M/pt.Ex,angle:(0,st.NA)(m.angle),xOffset:(0,st.NA)(m.offsetX),yOffset:(0,st.NA)(m.offsetY),hAlign:(0,ft.x1)(m.horizontalAlignment),vAlign:(0,ft.g)(m.verticalAlignment),maxLineWidth:512,lineHeight:pt.xm*Math.max(.25,Math.min(C||1,4)),decoration:m.font.decoration||"none",isCIM:!0}).boundsT;return l[0]=$.x-$.halfWidth,l[1]=-$.y-$.halfHeight,l[2]=$.x+$.halfWidth,l[3]=-$.y+$.halfHeight,l}}class J{static getEnvelope(l,m){const d=new ft.uQ(m);if(Array.isArray(l)){let M;for(const E of l)M?M.union(D(d,E)):M=D(d,E);return M}return D(d,l)}static getTextureAnchor(l,m){const d=this.getEnvelope(l,m);if(!d)return[0,0,0];const w=d.height*x+2;return[(d.x+.5*d.width)*x/(d.width*x+2),-(d.y+.5*d.height)*x/w,w]}static rasterize(l,m,d,M,E=!0){const y=d||this.getEnvelope(m,M);if(!y)return[null,0,0,0,0];const w=(y.x+.5*y.width)*x,C=(y.y+.5*y.height)*x;l.width=y.width*x,l.height=y.height*x,d||(l.width+=2,l.height+=2);const X=l.getContext("2d"),W=ft.zA.createScale(x,-x);W.translate(.5*l.width-w,.5*l.height+C);const $=new ft.cD(X,M,W);switch(m.type){case"CIMPointSymbol":$.drawSymbol(m,{type:"point",x:0,y:0});break;case"CIMVectorMarker":{const dt=new ot.u;$.drawMarker(m,dt);break}}const _t=X.getImageData(0,0,l.width,l.height),ct=new Uint8Array(_t.data);if(E){let dt;for(let it=0;it<ct.length;it+=4)dt=ct[it+3]/255,ct[it]=ct[it]*dt,ct[it+1]=ct[it+1]*dt,ct[it+2]=ct[it+2]*dt}return[ct,l.width,l.height,-w/l.width,-C/l.height]}static fromTextSymbol(l){const{angle:m,color:d,font:M,haloColor:E,haloSize:y,horizontalAlignment:w,kerning:C,text:X,verticalAlignment:W,xoffset:$,yoffset:_t}=l;let ct,dt,it,mt,Ct;M&&(ct=M.family,dt=M.style,it=M.weight,mt=M.size,Ct=M.decoration);let Pt=!1;return X&&(Pt=(0,H.E)(X)[1]),{type:"CIMPointSymbol",symbolLayers:[{type:"CIMVectorMarker",enable:!0,anchorPointUnits:"Relative",dominantSizeAxis3D:"Y",size:10,billboardMode3D:"FaceNearPlane",frame:{xmin:-5,ymin:-5,xmax:5,ymax:5},markerGraphics:[{type:"CIMMarkerGraphic",geometry:{x:0,y:0},symbol:{type:"CIMTextSymbol",angle:m,blockProgression:Z.zV.BTT,depth3D:1,extrapolateBaselines:!0,fontEffects:Z.eZ.Normal,fontEncoding:Z.DD.Unicode,fontFamilyName:ct||"Arial",fontStyleName:N(dt,it),fontType:Z.Ky.Unspecified,haloSize:y,height:mt,hinting:Z.Dd.Default,horizontalAlignment:v(null!=w?w:"center"),kerning:C,letterWidth:100,ligatures:!0,lineGapType:"Multiple",offsetX:(0,st.NA)($),offsetY:(0,st.NA)(_t),strikethrough:"line-through"===Ct,underline:"underline"===Ct,symbol:{type:"CIMPolygonSymbol",symbolLayers:[{type:"CIMSolidFill",enable:!0,color:L(d)}]},haloSymbol:{type:"CIMPolygonSymbol",symbolLayers:[{type:"CIMSolidFill",enable:!0,color:L(E)}]},shadowColor:[0,0,0,255],shadowOffsetX:1,shadowOffsetY:1,textCase:"Normal",textDirection:Pt?Z.UX.RTL:Z.UX.LTR,verticalAlignment:G(null!=W?W:"baseline"),verticalGlyphOrientation:Z.RS.Right,wordSpacing:100,billboardMode3D:Z.UR.FaceNearPlane},textString:X}],scaleSymbolsProportionally:!0,respectFrame:!0}],scaleX:1,angleAlignment:"Display"}}static fromPictureFillSymbol(l){const{height:m,outline:d,width:M,xoffset:E,xscale:y,yoffset:w,yscale:C}=l,X=[],W={type:"CIMPolygonSymbol",symbolLayers:X};if(d){const{cap:it,join:mt,miterLimit:Ct,width:Pt}=d;X.push({type:"CIMSolidStroke",color:L(d.color),capStyle:b(it),joinStyle:P(mt),miterLimit:Ct,width:Pt})}let $=l.url;"esriPFS"===l.type&&l.imageData&&($=l.imageData);const _t="angle"in l?l.angle:0;return X.push({type:"CIMPictureFill",invertBackfaceTexture:!1,scaleX:1,textureFilter:Z.Qb.Picture,tintColor:null,url:$,height:m*(C||1),width:M*(y||1),offsetX:(0,st.NA)(E),offsetY:(0,st.NA)(w),rotation:(0,st.NA)(-_t),colorSubstitutions:null}),W}static fromSimpleFillSymbol(l){const{color:m,style:d,outline:M}=l,E=[],y={type:"CIMPolygonSymbol",symbolLayers:E};let w=null;if(M){const{cap:C,join:X,style:W}=M;"solid"!==W&&"none"!==W&&"esriSLSSolid"!==W&&"esriSLSNull"!==W&&(w=[{type:"CIMGeometricEffectDashes",dashTemplate:nt(W,C),lineDashEnding:"NoConstraint",scaleDash:!0,offsetAlongLine:null}]),E.push({type:"CIMSolidStroke",color:L(M.color),capStyle:b(C),joinStyle:P(X),miterLimit:M.miterLimit,width:M.width,effects:w})}if(d&&"solid"!==d&&"none"!==d&&"esriSFSSolid"!==d&&"esriSFSNull"!==d){const C={type:"CIMLineSymbol",symbolLayers:[{type:"CIMSolidStroke",color:L(m),capStyle:Z.kP.Butt,joinStyle:Z.r4.Miter,width:.75}]};let X=0;const W=(0,S.fp)(Math.ceil(window.devicePixelRatio)),$=Tt(d)?8*W:10*W;switch(d){case"vertical":case"esriSFSVertical":X=90;break;case"forward-diagonal":case"esriSFSForwardDiagonal":case"diagonal-cross":case"esriSFSDiagonalCross":X=-45;break;case"backward-diagonal":case"esriSFSBackwardDiagonal":X=45;break;case"cross":case"esriSFSCross":X=0}E.push({type:"CIMHatchFill",lineSymbol:C,offsetX:0,offsetY:0,rotation:X,separation:$}),"cross"===d||"esriSFSCross"===d?E.push({type:"CIMHatchFill",lineSymbol:(0,ht.d9)(C),offsetX:0,offsetY:0,rotation:90,separation:$}):"diagonal-cross"!==d&&"esriSFSDiagonalCross"!==d||E.push({type:"CIMHatchFill",lineSymbol:(0,ht.d9)(C),offsetX:0,offsetY:0,rotation:45,separation:$})}else!d||"solid"!==d&&"esriSFSSolid"!==d||E.push({type:"CIMSolidFill",enable:!0,color:L(m)});return y}static fromSimpleLineSymbol(l){const{cap:m,color:d,join:M,marker:E,miterLimit:y,style:w,width:C}=l;let X=null;"solid"!==w&&"none"!==w&&"esriSLSSolid"!==w&&"esriSLSNull"!==w&&(X=[{type:"CIMGeometricEffectDashes",dashTemplate:nt(w,m),lineDashEnding:"NoConstraint",scaleDash:!0,offsetAlongLine:null}]);const W=[];if(E){let $;switch(E.placement){case"begin-end":$=Z.Tx.Both;break;case"begin":$=Z.Tx.JustBegin;break;case"end":$=Z.Tx.JustEnd;break;default:$=Z.Tx.None}const _t=J.fromSimpleMarker(E,C,d).symbolLayers[0];_t.markerPlacement={type:"CIMMarkerPlacementAtExtremities",angleToLine:!0,offset:0,extremityPlacement:$,offsetAlongLine:0},W.push(_t)}return"none"!==w&&"esriSLSNull"!==w&&W.push({type:"CIMSolidStroke",color:L(d),capStyle:b(m),joinStyle:P(M),miterLimit:y,width:C,effects:X}),{type:"CIMLineSymbol",symbolLayers:W}}static fromPictureMarker(l){const{angle:m,height:d,width:M,xoffset:E,yoffset:y}=l;let w=l.url;return"esriPMS"===l.type&&l.imageData&&(w=l.imageData),{type:"CIMPointSymbol",symbolLayers:[{type:"CIMPictureMarker",invertBackfaceTexture:!1,scaleX:1,textureFilter:Z.Qb.Picture,tintColor:null,url:w,size:d,width:M,offsetX:(0,st.NA)(E),offsetY:(0,st.NA)(y),rotation:(0,st.NA)(-m)}]}}static fromSimpleMarker(l,m,d){var X;const{style:M}=l,E=null!=(X=l.color)?X:d;if("path"===M){const W=[];if("outline"in l&&l.outline){const ct=l.outline;W.push({type:"CIMSolidStroke",enable:!0,width:(0,I.F2)(Math.round((0,I.Wz)(ct.width))),color:L(ct.color)})}W.push({type:"CIMSolidFill",enable:!0,color:L(E),path:l.path});const[$,_t]=vt("square");return{type:"CIMPointSymbol",symbolLayers:[{type:"CIMVectorMarker",enable:!0,rotation:(0,st.NA)(-l.angle),size:(0,st.NA)(l.size||6),offsetX:(0,st.NA)(l.xoffset),offsetY:(0,st.NA)(l.yoffset),frame:$,markerGraphics:[{type:"CIMMarkerGraphic",geometry:_t,symbol:{type:"CIMPolygonSymbol",symbolLayers:W}}]}]}}const[y,w]=vt(M);let C;if(w&&y){const W=[];if("outline"in l&&l.outline){const _t=l.outline;W.push({type:"CIMSolidStroke",enable:!0,width:_t.width>.667?(0,I.F2)(Math.round((0,I.Wz)(_t.width))):_t.width,color:L(_t.color)})}else!m||"line-marker"!==l.type||"cross"!==l.style&&"x"!==l.style||W.push({type:"CIMSolidStroke",enable:!0,width:m,color:L(E)});W.push({type:"CIMSolidFill",enable:!0,color:L(E)});const $={type:"CIMPolygonSymbol",symbolLayers:W};C={type:"CIMPointSymbol",symbolLayers:[{type:"CIMVectorMarker",enable:!0,rotation:(0,st.NA)(-l.angle),size:(0,st.NA)(l.size||6*m),offsetX:(0,st.NA)(l.xoffset),offsetY:(0,st.NA)(l.yoffset),frame:y,markerGraphics:[{type:"CIMMarkerGraphic",geometry:w,symbol:$}]}]}}return C}static fromCIMHatchFill(l){var C;const m=null!=(C=l.separation)?C:4,d=m/2,E=l.lineSymbol;let y=this._getLineSymbolPeriod(l.lineSymbol)||4;for(;y<4;)y*=2;const w=y/2;return{type:"CIMVectorMarker",frame:{xmin:-w,xmax:w,ymin:-d,ymax:d},markerGraphics:[{type:"CIMMarkerGraphic",geometry:{paths:[[[-w,0],[w,0]]]},symbol:E}],size:m}}static _getLineSymbolPeriod(l){if(l){const m=this._getEffectsRepeat(l.effects);if(m)return m;if(l.symbolLayers)for(const d of l.symbolLayers)if(d){const M=this._getEffectsRepeat(d.effects);if(M)return M;switch(d.type){case"CIMCharacterMarker":case"CIMPictureMarker":case"CIMVectorMarker":case"CIMObjectMarker3D":case"CIMglTFMarker3D":{const E=this._getPlacementRepeat(d.markerPlacement);if(E)return E}}}}return 0}static _getEffectsRepeat(l){if(l)for(const m of l)if(m)switch(m.type){case"CIMGeometricEffectDashes":{const d=m.dashTemplate;if(d&&d.length){let M=0;for(const E of d)M+=E;return 1&d.length&&(M*=2),M}break}case"CIMGeometricEffectWave":return m.period;default:q.error(`unsupported geometric effect type ${m.type}`)}return 0}static _getPlacementRepeat(l){if(l)switch(l.type){case"CIMMarkerPlacementAlongLineSameSize":case"CIMMarkerPlacementAlongLineRandomSize":case"CIMMarkerPlacementAlongLineVariableSize":{const m=l.placementTemplate;if(m&&m.length){let d=0;for(const M of m)d+=M;return 1&m.length&&(d*=2),d}break}}return 0}static fromCIMInsidePolygon(l){var $;const m=l.markerPlacement,d=Wt({type:l.type},l);d.markerPlacement=null,d.anchorPoint=null;const M=Math.abs(m.stepX),E=Math.abs(m.stepY),y=(null!=($=m.randomness)?$:100)/100;let w,C,X,W;if("Random"===m.gridType){const _t=(0,I.Wz)(pt.C1),ct=Math.max(Math.floor(_t/M),1),dt=Math.max(Math.floor(_t/E),1);w=ct*M/2,C=dt*E/2,X=2*C;const it=new U.Z(m.seed),mt=y*M/1.5,Ct=y*E/1.5;W=[];for(let Pt=0;Pt<ct;Pt++)for(let Dt=0;Dt<dt;Dt++){const Gt=Pt*M-w+mt*(.5-it.getFloat()),Ft=Dt*E-C+Ct*(.5-it.getFloat());W.push({x:Gt,y:Ft}),0===Pt&&W.push({x:Gt+2*w,y:Ft}),0===Dt&&W.push({x:Gt,y:Ft+2*C})}}else!0===m.shiftOddRows?(w=M/2,C=E,X=2*E,W=[{x:-w,y:0},{x:w,y:0},{x:0,y:C},{x:0,y:-C}]):(w=M/2,C=E/2,X=E,W=[{x:0,y:0}]);return{type:"CIMVectorMarker",frame:{xmin:-w,xmax:w,ymin:-C,ymax:C},markerGraphics:W.map(_t=>({type:"CIMMarkerGraphic",geometry:_t,symbol:{type:"CIMPointSymbol",symbolLayers:[d]}})),size:X}}static getFillColor(l){if(!l)return null;switch(l.type){case"CIMPolygonSymbol":if(l.symbolLayers)for(const m of l.symbolLayers){const d=J.getFillColor(m);if(null!=d)return d}break;case"CIMTextSymbol":return J.getFillColor(l.symbol);case"CIMSolidFill":return l.color}}static getStrokeColor(l){if(l)switch(l.type){case"CIMPolygonSymbol":case"CIMLineSymbol":if(l.symbolLayers)for(const m of l.symbolLayers){const d=J.getStrokeColor(m);if(void 0!==d)return d}break;case"CIMTextSymbol":return J.getStrokeColor(l.symbol);case"CIMSolidStroke":return l.color}}static getStrokeWidth(l){if(l)switch(l.type){case"CIMPolygonSymbol":case"CIMLineSymbol":if(l.symbolLayers)for(const m of l.symbolLayers){const d=J.getStrokeWidth(m);if(void 0!==d)return d}break;case"CIMTextSymbol":return J.getStrokeWidth(l.symbol);case"CIMSolidStroke":case"CIMGradientStroke":case"CIMPictureStroke":return l.width}}static getSize(l){if(l)switch(l.type){case"CIMTextSymbol":return l.height;case"CIMPointSymbol":{let m=0;if(l.symbolLayers)for(const d of l.symbolLayers)if(d)switch(d.type){case"CIMCharacterMarker":case"CIMPictureMarker":case"CIMVectorMarker":case"CIMObjectMarker3D":case"CIMglTFMarker3D":{const M=d.size;M>m&&(m=M);break}}return m}case"CIMLineSymbol":case"CIMPolygonSymbol":{let m=0;if(l.symbolLayers)for(const d of l.symbolLayers)if(d)switch(d.type){case"CIMSolidStroke":case"CIMPictureStroke":case"CIMGradientStroke":{const M=d.width;M>m&&(m=M);break}case"CIMCharacterMarker":case"CIMPictureMarker":case"CIMVectorMarker":case"CIMObjectMarker3D":case"CIMglTFMarker3D":if((0,st.gJ)(d.markerPlacement)){const M=d.size;M>m&&(m=M)}}return m}}}static getMarkerScaleRatio(l){return l&&"CIMVectorMarker"===l.type&&!1!==l.scaleSymbolsProportionally&&l.frame?l.size/(l.frame.ymax-l.frame.ymin):1}}class a{static rasterizeSimpleFill(l,m,d){"solid"!==m&&"none"!==m&&"esriSFSSolid"!==m&&"esriSFSNull"!==m||console.error("Unexpected: style does not require rasterization");const M=(0,S.fp)(Math.ceil(d)),E=Tt(m)?8*M:16*M,y=2*M;l.width=E,l.height=E;const w=l.getContext("2d");w.strokeStyle="#FFFFFF",w.lineWidth=M,w.beginPath(),"vertical"!==m&&"cross"!==m&&"esriSFSCross"!==m&&"esriSFSVertical"!==m||(w.moveTo(E/2,-y),w.lineTo(E/2,E+y)),"horizontal"!==m&&"cross"!==m&&"esriSFSCross"!==m&&"esriSFSHorizontal"!==m||(w.moveTo(-y,E/2),w.lineTo(E+y,E/2)),"forward-diagonal"!==m&&"diagonal-cross"!==m&&"esriSFSDiagonalCross"!==m&&"esriSFSForwardDiagonal"!==m||(w.moveTo(-y,-y),w.lineTo(E+y,E+y),w.moveTo(E-y,-y),w.lineTo(E+y,y),w.moveTo(-y,E-y),w.lineTo(y,E+y)),"backward-diagonal"!==m&&"diagonal-cross"!==m&&"esriSFSBackwardDiagonal"!==m&&"esriSFSDiagonalCross"!==m||(w.moveTo(E+y,-y),w.lineTo(-y,E+y),w.moveTo(y,-y),w.lineTo(-y,y),w.moveTo(E+y,E-y),w.lineTo(E-y,E+y)),w.stroke();const C=w.getImageData(0,0,l.width,l.height),X=new Uint8Array(C.data);let W;for(let $=0;$<X.length;$+=4)W=X[$+3]/255,X[$]=X[$]*W,X[$+1]=X[$+1]*W,X[$+2]=X[$+2]*W;return[X,l.width,l.height]}static rasterizeSimpleLine(l,m){return this.rasterizeDash(l,m)}static rasterizeDash(l,m){const d="Butt"===m,M="Square"===m,E=!d&&!M;l.length%2==1&&(l=[...l,...l]);const y=15.5;let C=0;for(const Pt of l)C+=Pt;const X=Math.round(C*y),W=new Float32Array(31*X),$=7.75;let _t=0,ct=0,dt=.5,it=!0;for(const Pt of l){for(_t=ct,ct+=Pt*y;dt<=ct;){let Dt=.5;for(;Dt<31;){const Gt=(Dt-.5)*X+dt-.5,Ft=E?(Dt-y)*(Dt-y):Math.abs(Dt-y);W[Gt]=it?d?Math.max(Math.max(_t+$-dt,Ft),Math.max(dt-ct+$,Ft)):Ft:E?Math.min((dt-_t)*(dt-_t)+Ft,(dt-ct)*(dt-ct)+Ft):M?Math.min(Math.max(dt-_t,Ft),Math.max(ct-dt,Ft)):Math.min(Math.max(dt-_t+$,Ft),Math.max(ct+$-dt,Ft)),Dt++}dt++}it=!it}const mt=W.length,Ct=new Uint8Array(4*mt);for(let Pt=0;Pt<mt;++Pt){const Dt=(E?Math.sqrt(W[Pt]):W[Pt])/y;(0,Q.I)(Dt,Ct,4*Pt)}return[Ct,X,31]}}class _{static findApplicableOverrides(l,m,d){if(l&&m){if(l.primitiveName){let M=!1;for(const E of d)if(E.primitiveName===l.primitiveName){M=!0;break}if(!M)for(const E of m)E.primitiveName===l.primitiveName&&d.push(E)}switch(l.type){case"CIMPointSymbol":case"CIMLineSymbol":case"CIMPolygonSymbol":if(l.effects)for(const M of l.effects)_.findApplicableOverrides(M,m,d);if(l.symbolLayers)for(const M of l.symbolLayers)_.findApplicableOverrides(M,m,d);break;case"CIMTextSymbol":break;case"CIMSolidStroke":case"CIMPictureStroke":case"CIMGradientStroke":case"CIMSolidFill":case"CIMPictureFill":case"CIMHatchFill":case"CIMGradientFill":case"CIMVectorMarker":case"CIMCharacterMarker":case"CIMPictureMarker":if(l.effects)for(const M of l.effects)_.findApplicableOverrides(M,m,d);if(l.markerPlacement&&_.findApplicableOverrides(l.markerPlacement,m,d),"CIMVectorMarker"===l.type){if(l.markerGraphics)for(const M of l.markerGraphics)_.findApplicableOverrides(M,m,d),_.findApplicableOverrides(M.symbol,m,d)}else"CIMCharacterMarker"===l.type?_.findApplicableOverrides(l.symbol,m,d):"CIMHatchFill"===l.type?_.findApplicableOverrides(l.lineSymbol,m,d):"CIMPictureMarker"===l.type&&_.findApplicableOverrides(l.animatedSymbolProperties,m,d)}}}static findEffectOverrides(l,m,d){var E;if(!m||!l)return;const M=l.length;for(let y=0;y<M;y++){const w=null==(E=l[y])?void 0:E.primitiveName;if(w){let C=!1;for(const X of d)if(X.primitiveName===w){C=!0;break}if(!C)for(const X of m)X.primitiveName===w&&d.push(X)}}}static applyOverrides(l,m,d,M){if(!m)return;const E=y=>y&&y.charAt(0).toLowerCase()+y.substr(1);if(l.primitiveName)for(const y of m)if(y.primitiveName===l.primitiveName){const w=E(y.propertyName);if(M&&M.push({cim:l,nocapPropertyName:w,value:l[w]}),y.expression&&(y.value=_.toValue(y.propertyName,y.expression)),d){let C=!1;for(const X of d)X.primitiveName===l.primitiveName&&(C=!0);C||d.push(y)}l[w]=y.value}switch(l.type){case"CIMPointSymbol":case"CIMLineSymbol":case"CIMPolygonSymbol":if(l.effects)for(const y of l.effects)_.applyOverrides(y,m,d,M);if(l.symbolLayers)for(const y of l.symbolLayers)_.applyOverrides(y,m,d,M);break;case"CIMTextSymbol":break;case"CIMSolidStroke":case"CIMSolidFill":case"CIMVectorMarker":if(l.effects)for(const y of l.effects)_.applyOverrides(y,m,d,M);if("CIMVectorMarker"===l.type&&l.markerGraphics)for(const y of l.markerGraphics)_.applyOverrides(y,m,d,M),_.applyOverrides(y.symbol,m,d,M)}}static restoreOverrides(l){for(const m of l)m.cim[m.nocapPropertyName]=m.value}static buildOverrideKey(l){let m="";for(const d of l)void 0!==d.value&&(m+=`${d.primitiveName}${d.propertyName}${JSON.stringify(d.value)}`);return m}static toValue(l,m){if("DashTemplate"===l)return m.split(" ").map(d=>Number(d));if("Color"===l){const d=new ut.Z(m).toRgba();return d[3]*=255,d}return m}}const b=z=>{if(!z)return Z.kP.Butt;switch(z){case"butt":return Z.kP.Butt;case"square":return Z.kP.Square;case"round":return Z.kP.Round}},P=z=>{if(!z)return Z.r4.Miter;switch(z){case"miter":return Z.r4.Miter;case"round":return Z.r4.Round;case"bevel":return Z.r4.Bevel}},v=z=>{if((0,xt.Wi)(z))return"Center";switch(z){case"left":return"Left";case"right":return"Right";case"center":return"Center"}},G=z=>{if((0,xt.Wi)(z))return"Center";switch(z){case"baseline":return"Baseline";case"top":return"Top";case"middle":return"Center";case"bottom":return"Bottom"}},L=z=>{if(!z)return[0,0,0,0];const{r:l,g:m,b:d,a:M}=z;return[l,m,d,255*M]},N=(z,l)=>{const m=rt(l),d=lt(z);return m&&d?`${m}-${d}`:`${m}${d}`},rt=z=>{if(!z)return"";switch(z.toLowerCase()){case"bold":case"bolder":return"bold"}return""},lt=z=>{if(!z)return"";switch(z.toLowerCase()){case"italic":case"oblique":return"italic"}return""},nt=(z,l)=>{const m="butt"===l;switch(z){case"dash":case"esriSLSDash":return m?[4,3]:[3,4];case"dash-dot":case"esriSLSDashDot":return m?[4,3,1,3]:[3,4,0,4];case"dot":case"esriSLSDot":return m?[1,3]:[0,4];case"long-dash":case"esriSLSLongDash":return m?[8,3]:[7,4];case"long-dash-dot":case"esriSLSLongDashDot":return m?[8,3,1,3]:[7,4,0,4];case"long-dash-dot-dot":case"esriSLSDashDotDot":return m?[8,3,1,3,1,3]:[7,4,0,4,0,4];case"short-dash":case"esriSLSShortDash":return m?[4,1]:[3,2];case"short-dash-dot":case"esriSLSShortDashDot":return m?[4,1,1,1]:[3,2,0,2];case"short-dash-dot-dot":case"esriSLSShortDashDotDot":return m?[4,1,1,1,1,1]:[3,2,0,2,0,2];case"short-dot":case"esriSLSShortDot":return m?[1,1]:[0,2];case"solid":case"esriSLSSolid":case"none":return q.error("Unexpected: style does not require rasterization"),[0,0];default:return q.error(`Tried to rasterize SLS, but found an unexpected style: ${z}!`),[0,0]}},vt=z=>{let d,M;const E=z;if("circle"===E||"esriSMSCircle"===E){let w=Math.acos(.995),C=Math.ceil(kt/w/4);0===C&&(C=1),w=It/C,C*=4;const X=[];X.push([50,0]);for(let W=1;W<C;W++)X.push([50*Math.cos(W*w),-50*Math.sin(W*w)]);X.push([50,0]),d={rings:[X]},M={xmin:-50,ymin:-50,xmax:50,ymax:50}}else if("cross"===E||"esriSMSCross"===E)d={rings:[[[0,50],[0,0],[50,0],[50,-0],[0,-0],[0,-50],[-0,-50],[-0,-0],[-50,-0],[-50,0],[-0,0],[-0,50],[0,50]]]},M={xmin:-50,ymin:-50,xmax:50,ymax:50};else if("diamond"===E||"esriSMSDiamond"===E)d={rings:[[[-50,0],[0,50],[50,0],[0,-50],[-50,0]]]},M={xmin:-50,ymin:-50,xmax:50,ymax:50};else if("square"===E||"esriSMSSquare"===E)d={rings:[[[-50,-50],[-50,50],[50,50],[50,-50],[-50,-50]]]},M={xmin:-50,ymin:-50,xmax:50,ymax:50};else if("x"===E||"esriSMSX"===E)d={rings:[[[0,0],[50,50],[50,50],[0,0],[50,-50],[50,-50],[0,-0],[-50,-50],[-50,-50],[-0,0],[-50,50],[-50,50],[0,0]]]},M={xmin:-50,ymin:-50,xmax:50,ymax:50};else if("triangle"===E||"esriSMSTriangle"===E){const y=57.735026918962575,w=-y,C=2/3*100,X=C-100;d={rings:[[[w,X],[0,C],[y,X],[w,X]]]},M={xmin:w,ymin:X,xmax:y,ymax:C}}else"arrow"===E&&(d={rings:[[[-50,50],[50,0],[-50,-50],[-33,-20],[-33,20],[-50,50]]]},M={xmin:-50,ymin:-50,xmax:50,ymax:50});return[M,d]},Tt=z=>"vertical"===z||"horizontal"===z||"cross"===z||"esriSFSCross"===z||"esriSFSVertical"===z||"esriSFSHorizontal"===z},31375:(Rt,yt,R)=>{R.d(yt,{Z:()=>ut});class ut{constructor(Q=0,ht=0,bt=0,S=0){this.x=Q,this.y=ht,this.width=bt,this.height=S}get isEmpty(){return this.width<=0||this.height<=0}union(Q){this.x=Math.min(this.x,Q.x),this.y=Math.min(this.y,Q.y),this.width=Math.max(this.width,Q.width),this.height=Math.max(this.height,Q.height)}}},68937:(Rt,yt,R)=>{R.d(yt,{Z:()=>ht});var ut=R(23841);class ht{rasterizeText(U,I){this._textRasterizationCanvas||(this._textRasterizationCanvas=document.createElement("canvas"));const Y=this._textRasterizationCanvas,j=Y.getContext("2d");this._setFontProperties(j,I),this.parameters=I,this.textLines=U.split(/\r?\n/),this.lineHeight=this._computeLineHeight();const ot=this._computeTextWidth(j,I),{decoration:ft,weight:Z}=I.font;this.lineThroughWidthOffset=ft&&"line-through"===ft?.1*this.lineHeight:0;const st=this.lineHeight*this.textLines.length;Y.width=ot+2*this.lineThroughWidthOffset,Y.height=st,this.renderedLineHeight=Math.round(this.lineHeight*I.pixelRatio),this.renderedHaloSize=I.halo.size*I.pixelRatio,this.renderedWidth=ot*I.pixelRatio,this.renderedHeight=st*I.pixelRatio,this.lineThroughWidthOffset*=I.pixelRatio,this.fillStyle=function Q(xt){return`rgba(${xt.slice(0,3).toString()},${xt[3]})`}(I.color),this.haloStyle=function H(xt){return`rgb(${xt.slice(0,3).toString()})`}(I.halo.color);const wt=this.renderedLineHeight,pt=this.renderedHaloSize;this._setFontProperties(j,I);const zt=function bt(xt,U){return"center"===xt?.5*U:"right"===xt?U:0}(j.textAlign,this.renderedWidth)+pt,kt=pt;let Ot=this.lineThroughWidthOffset,Lt=0;pt>0&&this._renderHalo(j,zt,kt,Ot,Lt,I),Lt+=kt,Ot+=zt;for(const D of this.textLines)j.globalCompositeOperation="destination-out",j.fillStyle="rgb(0, 0, 0)",j.fillText(D,Ot,Lt),j.globalCompositeOperation="source-over",j.fillStyle=this.fillStyle,j.fillText(D,Ot,Lt),ft&&"none"!==ft&&this._renderDecoration(j,Ot,Lt,ft,Z),Lt+=wt;const x=this.renderedWidth+2*this.lineThroughWidthOffset,V=this.renderedHeight,q=j.getImageData(0,0,x,V),k=new Uint8Array(q.data);if(I.premultiplyColors){let D;for(let F=0;F<k.length;F+=4)D=k[F+3]/255,k[F]=k[F]*D,k[F+1]=k[F+1]*D,k[F+2]=k[F+2]*D}return{size:[x,V],image:new Uint32Array(k.buffer),sdf:!1,simplePattern:!1,anchorX:0,anchorY:0}}_renderHalo(U,I,Y,j,ot,ft){const Z=this.renderedWidth,st=this.renderedHeight;this._haloRasterizationCanvas||(this._haloRasterizationCanvas=document.createElement("canvas")),this._haloRasterizationCanvas.width=Z,this._haloRasterizationCanvas.height=st;const wt=this._haloRasterizationCanvas,pt=wt.getContext("2d");pt.clearRect(0,0,Z,st),this._setFontProperties(pt,ft);const{decoration:zt,weight:kt}=ft.font;pt.fillStyle=this.haloStyle,pt.strokeStyle=this.haloStyle;const It=this.renderedHaloSize<3;pt.lineJoin=It?"miter":"round",It?this._renderHaloEmulated(pt,I,Y,zt,kt):this._renderHaloNative(pt,I,Y,zt,kt),U.globalAlpha=this.parameters.halo.color[3],U.drawImage(wt,0,0,Z,st,j,ot,Z,st),U.globalAlpha=1}_renderHaloEmulated(U,I,Y,j,ot){const ft=this.renderedLineHeight,Z=this.renderedHaloSize;for(const st of this.textLines){for(const[wt,pt]of S)U.fillText(st,I+Z*wt,Y+Z*pt);j&&"none"!==j&&this._renderDecoration(U,I,Y,j,ot),Y+=ft}}_renderHaloNative(U,I,Y,j,ot){const ft=this.renderedLineHeight,Z=this.renderedHaloSize;for(const st of this.textLines){const wt=2*Z,pt=5,zt=.1;for(let kt=0;kt<pt;kt++)U.lineWidth=(1-(pt-1)*zt+kt*zt)*wt,U.strokeText(st,I,Y),j&&"none"!==j&&this._renderDecoration(U,I,Y,j,ot);Y+=ft}}_setFontProperties(U,I){const Y=I.font,j=`${Y.style} ${Y.weight} ${(0,ut.F2)(I.size*I.pixelRatio)}px ${Y.family}, sans-serif`;let ot;switch(U.font=j,U.textBaseline="top",I.horizontalAlignment){case"left":default:ot="left";break;case"right":ot="right";break;case"center":ot="center"}U.textAlign=ot}computeTextSize(U,I){this._textRasterizationCanvas||(this._textRasterizationCanvas=document.createElement("canvas"));const Y=this._textRasterizationCanvas,j=Y.getContext("2d");this._setFontProperties(j,I),this.parameters=I,this.textLines=U.split(/\r?\n/),this.lineHeight=this._computeLineHeight();const ot=this._computeTextWidth(j,I),ft=this.lineHeight*this.textLines.length;return Y.width=ot,Y.height=ft,[ot*I.pixelRatio,ft*I.pixelRatio]}_computeTextWidth(U,I){let Y=0;for(const ot of this.textLines)Y=Math.max(Y,U.measureText(ot).width);const j=I.font;return("italic"===j.style||"oblique"===j.style||"string"==typeof j.weight&&("bold"===j.weight||"bolder"===j.weight)||"number"==typeof j.weight&&j.weight>600)&&(Y+=.3*U.measureText("w").width),Y+=2*this.parameters.halo.size,Math.round(Y)}_computeLineHeight(){let U=1.275*this.parameters.size;const I=this.parameters.font.decoration;return I&&"underline"===I&&(U*=1.3),Math.round(U+2*this.parameters.halo.size)}_renderDecoration(U,I,Y,j,ot){const ft=.9*this.lineHeight,Z="bold"===ot?.06:"bolder"===ot?.09:.04;switch(U.textAlign){case"center":I-=this.renderedWidth/2;break;case"right":I-=this.renderedWidth}const st=U.textBaseline;if("underline"===j)switch(st){case"top":Y+=ft;break;case"middle":Y+=ft/2}else if("line-through"===j)switch(st){case"top":Y+=ft/1.5;break;case"middle":Y+=ft/3}U.save(),U.beginPath(),U.strokeStyle=U.fillStyle,U.lineWidth=Math.ceil(ft*Z),U.moveTo(I-this.lineThroughWidthOffset,Y),U.lineTo(I+this.renderedWidth+2*this.lineThroughWidthOffset,Y),U.stroke(),U.restore()}}const S=[];for(let U=0;U<360;U+=22.5)S.push([Math.cos(Math.PI*U/180),Math.sin(Math.PI*U/180)])},25797:(Rt,yt,R)=>{R.d(yt,{Nr:()=>V});var ut=R(31478),H=R(12225),Q=R(67831),ht=R(9545),bt=R(61261),S=R(5254),xt=R(84439);class U{constructor(k,D,F,K){this.center=(0,ht.f)(k,D),this.centerT=(0,ht.c)(),this.halfWidth=F/2,this.halfHeight=K/2,this.width=F,this.height=K}get x(){return this.center[0]}get y(){return this.center[1]}get blX(){return this.center[0]+this.halfWidth}get blY(){return this.center[1]+this.halfHeight}get trX(){return this.center[0]-this.halfWidth}get trY(){return this.center[1]-this.halfHeight}get xmin(){return this.x-this.halfWidth}get xmax(){return this.x+this.halfWidth}get ymin(){return this.y-this.halfHeight}get ymax(){return this.y+this.halfHeight}set x(k){this.center[0]=k}set y(k){this.center[1]=k}clone(){return new U(this.x,this.y,this.width,this.height)}serialize(k){return k.writeF32(this.center[0]),k.writeF32(this.center[1]),k.push(this.width),k.push(this.height),k}findCollisionDelta(k,D=4){const F=Math.abs(k.centerT[0]-this.centerT[0]),K=Math.abs(k.centerT[1]-this.centerT[1]),J=Math.min((k.halfWidth+this.halfWidth+D)/F,(k.halfHeight+this.halfHeight+D)/K);return Math.log2(J)}extend(k){const D=Math.min(this.xmin,k.xmin),F=Math.min(this.ymin,k.ymin),K=Math.max(this.xmax,k.xmax)-D,et=Math.max(this.ymax,k.ymax)-F,gt=D+K/2,J=F+et/2;this.width=K,this.height=et,this.halfWidth=K/2,this.halfHeight=et/2,this.x=gt,this.y=J}static deserialize(k){const D=k.readF32(),F=k.readF32(),K=k.readInt32(),et=k.readInt32();return new U(D,F,K,et)}}const st=Math.PI/180;class wt{constructor(k,D,F,K){this._rotationT=(0,H.c)(),this._xBounds=0,this._yBounds=0,this.minZoom=0,this.maxZoom=255,this._bounds=null;const et=F.rect,gt=new Float32Array(8);D*=K;const J=F.code?et.width*K:F.metrics.width,a=F.code?et.height*K:F.metrics.height;gt[0]=k*=K,gt[1]=D,gt[2]=k+J,gt[3]=D,gt[4]=k,gt[5]=D+a,gt[6]=k+J,gt[7]=D+a,this._data=gt,this._setTextureCoords(et),this._scale=K,this._mosaic=F,this.x=k,this.y=D,this.maxOffset=Math.max(k+J,D+a)}get width(){return this._mosaic.metrics.width*this._scale}get mosaic(){return this._mosaic}set angle(k){this._angle=k,(0,ut.c)(this._rotationT,-k),this._setOffsets(this._data)}get angle(){return this._angle}get xTopLeft(){return this._data[0]}get yTopLeft(){return this._data[1]}get xBottomRight(){return this._data[6]}get yBottomRight(){return this._data[7]}get texcoords(){return this._texcoords}get textureBinding(){return this._mosaic.textureBinding}get offsets(){return this._offsets||this._setOffsets(this._data),this._offsets}get char(){return String.fromCharCode(this._mosaic.code)}get code(){return this._mosaic.code}get bounds(){if(!this._bounds){const{height:k,width:D}=this._mosaic.metrics,F=D*this._scale,K=Math.abs(k)*this._scale,et=new Float32Array(8);et[0]=this.x,et[1]=this.y,et[2]=this.x+F,et[3]=this.y,et[4]=this.x,et[5]=this.y+K,et[6]=this.x+F,et[7]=this.y+K;const gt=(0,ut.m)((0,H.c)(),this._rotationT,this._T);(0,H.t)(et,et,gt);let J=1/0,a=1/0,_=0,b=0;for(let N=0;N<4;N++){const rt=et[2*N],lt=et[2*N+1];J=Math.min(J,rt),a=Math.min(a,lt),_=Math.max(_,rt),b=Math.max(b,lt)}const P=_-J,v=b-a;this._bounds=new U(J+P/2,a+v/2,P,v)}return this._bounds}setTransform(k){this._T=k,this._offsets=null}_setOffsets(k){this._offsets||(this._offsets={upperLeft:0,upperRight:0,lowerLeft:0,lowerRight:0});const D=this._offsets,F=new Float32Array(8),K=(0,ut.m)((0,H.c)(),this._rotationT,this._T);(0,H.t)(F,k,K),D.upperLeft=(0,S.UJ)(8*F[0],8*F[1]),D.upperRight=(0,S.UJ)(8*F[2],8*F[3]),D.lowerLeft=(0,S.UJ)(8*F[4],8*F[5]),D.lowerRight=(0,S.UJ)(8*F[6],8*F[7])}_setTextureCoords({x:k,y:D,width:F,height:K}){this._texcoords={upperLeft:(0,S.UJ)(k,D),upperRight:(0,S.UJ)(k+F,D),lowerLeft:(0,S.UJ)(k,D+K),lowerRight:(0,S.UJ)(k+F,D+K)}}}const pt=(q,k)=>({code:0,page:0,sdf:!0,rect:new xt.Z(0,0,11,8),textureBinding:k,metrics:{advance:0,height:4,width:q,left:0,top:0}});class zt{constructor(k,D,F){this._rotation=0,this._decorate(k,D,F),this.glyphs=k,this.bounds=this._createBounds(k),this.isMultiline=D.length>1,this._hasRotation=0!==F.angle,this._T=this._createGlyphTransform(this.bounds,F);for(const K of k)K.setTransform(this._T)}setRotation(k){if(0===k&&0===this._rotation)return;this._rotation=k;const D=this._T,F=(0,ut.c)((0,H.c)(),k);(0,ut.m)(D,F,D);for(const K of this.glyphs)K.setTransform(this._T)}_decorate(k,D,F){if(!F.decoration||"none"===F.decoration||!k.length)return;const K=F.scale,et="underline"===F.decoration?30:20,gt=k[0].textureBinding;for(const J of D)k.push(new wt(J.startX*K,J.startY*K+et*K,pt((J.width+J.glyphWidthEnd)*K,gt),1))}get boundsT(){const k=this.bounds,D=(0,Q.a)((0,ht.c)(),k.x,k.y);if((0,Q.t)(D,D,this._T),this._hasRotation){const F=Math.max(k.width,k.height);return new U(D[0],D[1],F,F)}return new U(D[0],D[1],k.width,k.height)}_createBounds(k){let D=1/0,F=1/0,K=0,et=0;for(const a of k)D=Math.min(D,a.xTopLeft),F=Math.min(F,a.yTopLeft),K=Math.max(K,a.xTopLeft+a.width),et=Math.max(et,a.yBottomRight);const gt=K-D,J=et-F;return new U(D+gt/2,F+J/2,gt,J)}_createGlyphTransform(k,D){const F=st*D.angle,K=(0,H.c)(),et=(0,ht.c)();return(0,ut.t)(K,K,(0,Q.a)(et,D.xOffset,-D.yOffset)),D.isCIM?(0,ut.r)(K,K,F):((0,ut.t)(K,K,(0,Q.a)(et,k.x,k.y)),(0,ut.r)(K,K,F),(0,ut.t)(K,K,(0,Q.a)(et,-k.x,-k.y))),K}}class kt{constructor(k,D,F,K,et,gt){this.glyphWidthEnd=0,this.startX=0,this.startY=0,this.start=Math.max(0,Math.min(D,F)),this.end=Math.max(0,Math.max(D,F)),this.end<k.length&&(this.glyphWidthEnd=k[this.end].metrics.width),this.width=K,this.yMin=et,this.yMax=gt}}const It=q=>10===q,Ot=q=>32===q;function V(q,k,D){const F=D.scale,K=new Array,et=function Lt(q,k,D){const F=new Array,et=D.maxLineWidth*(1/D.scale),gt=k?q.length-1:0,J=k?-1:q.length,a=k?-1:1;let _=gt,b=0,P=0,v=_,G=v,L=0,N=1/0,rt=0;for(;_!==J;){const{code:nt,metrics:at}=q[_],vt=Math.abs(at.top);It(nt)||Ot(nt)||(N=Math.min(N,vt),rt=Math.max(rt,vt+at.height)),It(nt)?(_!==gt&&(F.push(new kt(q,v,_-a,b,N,rt)),N=1/0,rt=0),b=0,v=_+a,G=_+a,P=0):Ot(nt)?(G=_+a,P=0,L=at.advance,b+=at.advance):b>et?(G!==v?(b-=L,F.push(new kt(q,v,G-2*a,b-P,N,rt)),N=1/0,rt=0,v=G,b=P):(F.push(new kt(q,v,_-a,b,N,rt)),N=1/0,rt=0,v=_,G=_,b=0),b+=at.advance,P+=at.advance):(b+=at.advance,P+=at.advance),_+=a}const lt=new kt(q,v,_-a,b,N,rt);return lt.start>=0&&lt.end<q.length&&F.push(lt),F}(q,k,D),gt=function x(q,k){let D=0;for(let et=0;et<q.length;et++){const{width:gt}=q[et];D=Math.max(gt,D)}const K=q[0].yMin;return{x:0,y:K,height:q[q.length-1].yMax+k.lineHeight*(q.length-1)+("underline"===k.decoration?4:0)-K,width:D}}(et,D),{vAlign:J,hAlign:a}=D,_=J===bt.TR.Baseline?1:0,P=(1-_)*-gt.y+gt.height/2*(_?0:J-1)+-26*(_?1:0);for(let v=0;v<et.length;v++){const{start:G,end:L,width:N}=et[v];let rt=-1*(a+1)*(N/2)-3;const lt=v*D.lineHeight+P-3;et[v].startX=rt,et[v].startY=lt;for(let nt=G;nt<=L;nt++){const at=q[nt];if(It(at.code))continue;const vt=new wt(rt+at.metrics.left,lt-at.metrics.top,at,F);rt+=at.metrics.advance,K.push(vt)}}return new zt(K,et,D)}}}]);