"use strict";(self.webpackChunkchasse_pwa_front=self.webpackChunkchasse_pwa_front||[]).push([[7692],{60295:(ht,q,Z)=>{Z.d(q,{Z:()=>rt});var $,S=Z(17626),L=(Z(8314),Z(26584)),tt=Z(86810),et=Z(58817),it=Z(63290),st=Z(62208),X=Z(77712),lt=Z(66656),nt=Z(76898);const J=it.Z.getLogger("esri.layers.support.PixelBlock");let K=$=class extends tt.wq{constructor(g){super(g),this.width=null,this.height=null,this.pixelType="f32",this.validPixelCount=null,this.mask=null,this.maskIsAlpha=!1,this.pixels=null,this.statistics=null}static createEmptyBand(g,m){return new($.getPixelArrayConstructor(g))(m)}static getPixelArrayConstructor(g){let m;switch(g){case"u1":case"u2":case"u4":case"u8":m=Uint8Array;break;case"u16":m=Uint16Array;break;case"u32":m=Uint32Array;break;case"s8":m=Int8Array;break;case"s16":m=Int16Array;break;case"s32":m=Int32Array;break;case"f32":case"c64":case"c128":case"unknown":m=Float32Array;break;case"f64":m=Float64Array}return m}castPixelType(g){if(!g)return"f32";let m=g.toLowerCase();return["u1","u2","u4"].includes(m)?m="u8":["unknown","u8","s8","u16","s16","u32","s32","f32","f64"].includes(m)||(m="f32"),m}getPlaneCount(){return this.pixels&&this.pixels.length}addData(g){if(!g.pixels||g.pixels.length!==this.width*this.height)throw new L.Z("pixelblock:invalid-or-missing-pixels","add data requires valid pixels array that has same length defined by pixel block width * height");this.pixels||(this.pixels=[]),this.statistics||(this.statistics=[]),this.pixels.push(g.pixels),this.statistics.push(g.statistics||{minValue:null,maxValue:null})}getAsRGBA(){const g=new ArrayBuffer(this.width*this.height*4);switch(this.pixelType){case"s8":case"s16":case"u16":case"s32":case"u32":case"f32":case"f64":this._fillFromNon8Bit(g);break;default:this._fillFrom8Bit(g)}return new Uint8ClampedArray(g)}getAsRGBAFloat(){const g=new Float32Array(this.width*this.height*4);return this._fillFrom32Bit(g),g}updateStatistics(){this.statistics=this.pixels.map(U=>this._calculateBandStatistics(U,this.mask));const g=this.mask;let m=0;if(g)for(let U=0;U<g.length;U++)g[U]&&m++;else m=this.width*this.height;this.validPixelCount=m}clamp(g){if(!g||"f64"===g||"f32"===g)return;let m;switch(g){case"u8":m=[0,255];break;case"u16":m=[0,65535];break;case"u32":m=[0,4294967295];break;case"s8":m=[-128,127];break;case"s16":m=[-32768,32767];break;case"s32":m=[-2147483648,2147483647];break;default:m=[-34e38,34e38]}const[U,M]=m,P=this.pixels,C=this.width*this.height,_=P.length;let v,D,R;const e=[];for(let r=0;r<_;r++){R=$.createEmptyBand(g,C),v=P[r];for(let t=0;t<C;t++)D=v[t],R[t]=D>M?M:D<U?U:D;e.push(R)}this.pixels=e,this.pixelType=g}extractBands(g){if((0,st.Wi)(g)||0===g.length||null==this.pixels||0===this.pixels.length)return this;const m=this.pixels.length,U=g.some(P=>P>=this.pixels.length),M=m===g.length&&!g.some((P,C)=>P!==C);return U||M?this:new $({pixelType:this.pixelType,width:this.width,height:this.height,mask:this.mask,validPixelCount:this.validPixelCount,maskIsAlpha:this.maskIsAlpha,pixels:g.map(P=>this.pixels[P]),statistics:this.statistics&&g.map(P=>this.statistics[P])})}clone(){const g=new $({width:this.width,height:this.height,pixelType:this.pixelType,maskIsAlpha:this.maskIsAlpha,validPixelCount:this.validPixelCount});let m;this.mask&&(g.mask=this.mask instanceof Uint8Array?new Uint8Array(this.mask):this.mask.slice(0));const U=$.getPixelArrayConstructor(this.pixelType);if(this.pixels&&this.pixels.length>0){g.pixels=[];const M=this.pixels[0].slice;for(m=0;m<this.pixels.length;m++)g.pixels[m]=M?this.pixels[m].slice(0,this.pixels[m].length):new U(this.pixels[m])}if(this.statistics)for(g.statistics=[],m=0;m<this.statistics.length;m++)g.statistics[m]=(0,et.d9)(this.statistics[m]);return g}_fillFrom8Bit(g){const{mask:m,maskIsAlpha:U,pixels:M}=this;if(!g||!M||!M.length)return void J.error("getAsRGBA()","Unable to convert to RGBA. The input pixel block is empty.");let P,C,_,v;P=C=_=M[0],M.length>=3?(C=M[1],_=M[2]):2===M.length&&(C=M[1]);const D=new Uint32Array(g),R=this.width*this.height;if(P.length===R)if(m&&m.length===R)if(U)for(v=0;v<R;v++)m[v]&&(D[v]=m[v]<<24|_[v]<<16|C[v]<<8|P[v]);else for(v=0;v<R;v++)m[v]&&(D[v]=255<<24|_[v]<<16|C[v]<<8|P[v]);else for(v=0;v<R;v++)D[v]=255<<24|_[v]<<16|C[v]<<8|P[v];else J.error("getAsRGBA()","Unable to convert to RGBA. The pixelblock is invalid.")}_fillFromNon8Bit(g){const{pixels:m,mask:U,statistics:M}=this;if(!g||!m||!m.length)return void J.error("getAsRGBA()","Unable to convert to RGBA. The input pixel block is empty.");const P=this.pixelType;let C=1,_=0,v=1;if(M&&M.length>0)_=M.map(l=>l.minValue).reduce((l,h)=>Math.min(l,h)),v=M.map(l=>l.maxValue-l.minValue).reduce((l,h)=>Math.max(l,h)),C=255/v;else{let l=255;"s8"===P?(_=-128,l=127):"u16"===P?l=65535:"s16"===P?(_=-32768,l=32767):"u32"===P?l=4294967295:"s32"===P?(_=-2147483648,l=2147483647):"f32"===P?(_=-34e38,l=34e38):"f64"===P&&(_=-Number.MAX_VALUE,l=Number.MAX_VALUE),C=255/(l-_)}const D=new Uint32Array(g),R=this.width*this.height;let e,r,t,i,o;if(e=r=t=m[0],e.length!==R)return J.error("getAsRGBA()","Unable to convert to RGBA. The pixelblock is invalid.");if(m.length>=2)if(r=m[1],m.length>=3&&(t=m[2]),U&&U.length===R)for(i=0;i<R;i++)U[i]&&(D[i]=255<<24|(t[i]-_)*C<<16|(r[i]-_)*C<<8|(e[i]-_)*C);else for(i=0;i<R;i++)D[i]=255<<24|(t[i]-_)*C<<16|(r[i]-_)*C<<8|(e[i]-_)*C;else if(U&&U.length===R)for(i=0;i<R;i++)o=(e[i]-_)*C,U[i]&&(D[i]=255<<24|o<<16|o<<8|o);else for(i=0;i<R;i++)o=(e[i]-_)*C,D[i]=255<<24|o<<16|o<<8|o}_fillFrom32Bit(g){const{pixels:m,mask:U}=this;if(!g||!m||!m.length)return J.error("getAsRGBAFloat()","Unable to convert to RGBA. The input pixel block is empty.");let M,P,C,_;M=P=C=m[0],m.length>=3?(P=m[1],C=m[2]):2===m.length&&(P=m[1]);const v=this.width*this.height;if(M.length!==v)return J.error("getAsRGBAFloat()","Unable to convert to RGBA. The pixelblock is invalid.");let D=0;if(U&&U.length===v)for(_=0;_<v;_++)g[D++]=M[_],g[D++]=P[_],g[D++]=C[_],g[D++]=1&U[_];else for(_=0;_<v;_++)g[D++]=M[_],g[D++]=P[_],g[D++]=C[_],g[D++]=1}_calculateBandStatistics(g,m){let U=1/0,M=-1/0;const P=g.length;let C,_=0;if(m)for(C=0;C<P;C++)m[C]&&(_=g[C],U=_<U?_:U,M=_>M?_:M);else for(C=0;C<P;C++)_=g[C],U=_<U?_:U,M=_>M?_:M;return{minValue:U,maxValue:M}}};(0,S._)([(0,X.Cb)({json:{write:!0}})],K.prototype,"width",void 0),(0,S._)([(0,X.Cb)({json:{write:!0}})],K.prototype,"height",void 0),(0,S._)([(0,X.Cb)({json:{write:!0}})],K.prototype,"pixelType",void 0),(0,S._)([(0,lt.p)("pixelType")],K.prototype,"castPixelType",null),(0,S._)([(0,X.Cb)({json:{write:!0}})],K.prototype,"validPixelCount",void 0),(0,S._)([(0,X.Cb)({json:{write:!0}})],K.prototype,"mask",void 0),(0,S._)([(0,X.Cb)({json:{write:!0}})],K.prototype,"maskIsAlpha",void 0),(0,S._)([(0,X.Cb)({json:{write:!0}})],K.prototype,"pixels",void 0),(0,S._)([(0,X.Cb)({json:{write:!0}})],K.prototype,"statistics",void 0),K=$=(0,S._)([(0,nt.j)("esri.layers.support.PixelBlock")],K);const rt=K},79751:(ht,q,Z)=>{Z.d(q,{Kh:()=>nt,Pz:()=>et,Qh:()=>D,SJ:()=>it,Uk:()=>R,Vl:()=>_,XV:()=>st,nk:()=>L,pW:()=>rt,qF:()=>tt,us:()=>J,zp:()=>X});var S=Z(62208),V=Z(60295);function L(e){return(0,S.pC)(e)&&"esri.layers.support.PixelBlock"===e.declaredClass&&e.pixels&&e.pixels.length>0}function tt(e,r){if(!(null==r?void 0:r.length)||!L(e))return e;const t=e.pixels.length;return r&&r.some(i=>i>=t)||1===t&&1===r.length&&0===r[0]?e:t!==r.length||r.some((i,o)=>i!==o)?new V.Z({pixelType:e.pixelType,width:e.width,height:e.height,mask:e.mask,validPixelCount:e.validPixelCount,maskIsAlpha:e.maskIsAlpha,pixels:r.map(i=>e.pixels[i]),statistics:e.statistics&&r.map(i=>e.statistics[i])}):e}function et(e){if(!e)return;const r=e.colormap;if(!r||0===r.length)return;const t=r.sort((s,f)=>s[0]-f[0]);let i=0;t[0][0]<0&&(i=t[0][0]);const o=Math.max(256,t[t.length-1][0]-i+1),l=new Uint8Array(4*o),h=[];let x,n=0,c=0;const p=5===t[0].length;if(o>65536)return t.forEach(s=>{h[s[0]-i]=p?s.slice(1):s.slice(1).concat([255])}),{indexed2DColormap:h,offset:i,alphaSpecified:p};if(e.fillUnspecified)for(x=t[c],n=x[0]-i;n<o;n++)l[4*n]=x[1],l[4*n+1]=x[2],l[4*n+2]=x[3],l[4*n+3]=p?x[4]:255,n===x[0]-i&&(x=c===t.length-1?x:t[++c]);else for(n=0;n<t.length;n++)x=t[n],c=4*(x[0]-i),l[c]=x[1],l[c+1]=x[2],l[c+2]=x[3],l[c+3]=p?x[4]:255;return{indexedColormap:l,offset:i,alphaSpecified:p}}function it(e,r){if(!L(e)||!r&&(r.indexedColormap||r.indexed2DColormap))return e;const t=e.clone(),i=t.pixels;let o=t.mask;const l=t.width*t.height;if(1!==i.length)return e;const{indexedColormap:h,indexed2DColormap:x,offset:n,alphaSpecified:c}=r,p=h.length-1;let s=0;const f=i[0],a=new Uint8Array(f.length),d=new Uint8Array(f.length),u=new Uint8Array(f.length);let w,y=0;if(h)if(o)for(s=0;s<l;s++)o[s]&&(y=4*(f[s]-n),y<n||y>p?o[s]=0:(a[s]=h[y],d[s]=h[y+1],u[s]=h[y+2],o[s]=h[y+3]));else{for(o=new Uint8Array(l),s=0;s<l;s++)y=4*(f[s]-n),y<n||y>p?o[s]=0:(a[s]=h[y],d[s]=h[y+1],u[s]=h[y+2],o[s]=h[y+3]);t.mask=o}else if(o)for(s=0;s<l;s++)o[s]&&(w=x[f[s]],a[s]=w[0],d[s]=w[1],u[s]=w[2],o[s]=w[3]);else{for(o=new Uint8Array(l),s=0;s<l;s++)w=x[f[s]],a[s]=w[0],d[s]=w[1],u[s]=w[2],o[s]=w[3];t.mask=o}return t.pixels=[a,d,u],t.statistics=null,t.pixelType="u8",t.maskIsAlpha=c,t}function st(e,r){if(!L(e))return null;const{pixels:t,mask:i}=e,o=e.width*e.height,l=t.length;let h=r.lut;const{offset:x}=r;let n,c;h&&1===h[0].length&&(h=t.map(()=>h));const p=[];let s,f,a;if(x)if(null==i)for(n=0;n<l;n++){for(s=t[n],f=h[n],a=new Uint8Array(o),c=0;c<o;c++)a[c]=f[s[c]-x];p.push(a)}else for(n=0;n<l;n++){for(s=t[n],f=h[n],a=new Uint8Array(o),c=0;c<o;c++)i[c]&&(a[c]=f[s[c]-x]);p.push(a)}else if(null==i)for(n=0;n<l;n++){for(s=t[n],f=h[n],a=new Uint8Array(o),c=0;c<o;c++)a[c]=f[s[c]];p.push(a)}else for(n=0;n<l;n++){for(s=t[n],f=h[n],a=new Uint8Array(o),c=0;c<o;c++)i[c]&&(a[c]=f[s[c]]);p.push(a)}const d=new V.Z({width:e.width,height:e.height,pixels:p,mask:i,pixelType:"u8"});return d.updateStatistics(),d}function X(e,r){if(!L(e))return null;const t=e.clone(),{pixels:i}=t,o=t.width*t.height,l=r.length,h=Math.floor(l/2),x=r[Math.floor(h)],n=i[0];let c,p,s,f,a,d,u=!1;const w=new Uint8Array(o),y=new Uint8Array(o),k=new Uint8Array(o);let T=t.mask;const A=4===r[0].mappedColor.length;for(T||(T=new Uint8Array(o),T.fill(A?255:1),t.mask=T),a=0;a<o;a++)if(T[a]){for(c=n[a],u=!1,d=h,p=x,s=0,f=l-1;f-s>1;){if(c===p.value){u=!0;break}c>p.value?s=d:f=d,d=Math.floor((s+f)/2),p=r[Math.floor(d)]}u||(c===r[s].value?(p=r[s],u=!0):c===r[f].value?(p=r[f],u=!0):c<r[s].value?(u=!1,p=null):c>r[s].value&&(c<r[f].value?(p=r[s],u=!0):f===l-1?(u=!1,p=null):(p=r[f],u=!0))),u?(w[a]=p.mappedColor[0],y[a]=p.mappedColor[1],k[a]=p.mappedColor[2],T[a]=p.mappedColor[3]):w[a]=y[a]=k[a]=T[a]=0}return t.pixels=[w,y,k],t.mask=T,t.pixelType="u8",t.maskIsAlpha=A,t}function nt(e,r){if(!e||0===e.length)return null;const t=e.find(d=>d.pixelBlock);if(!t||(0,S.Wi)(t.pixelBlock))return null;const i=(t.extent.xmax-t.extent.xmin)/t.pixelBlock.width,o=(t.extent.ymax-t.extent.ymin)/t.pixelBlock.height,l=.01*Math.min(i,o),h=e.sort((d,u)=>Math.abs(d.extent.ymax-u.extent.ymax)>l?u.extent.ymax-d.extent.ymax:Math.abs(d.extent.xmin-u.extent.xmin)>l?d.extent.xmin-u.extent.xmin:0),x=Math.min.apply(null,h.map(d=>d.extent.xmin)),n=Math.min.apply(null,h.map(d=>d.extent.ymin)),c=Math.max.apply(null,h.map(d=>d.extent.xmax)),p=Math.max.apply(null,h.map(d=>d.extent.ymax)),s={x:Math.round((r.xmin-x)/i),y:Math.round((p-r.ymax)/o)},f={width:Math.round((c-x)/i),height:Math.round((p-n)/o)},a={width:Math.round((r.xmax-r.xmin)/i),height:Math.round((r.ymax-r.ymin)/o)};return Math.round(f.width/t.pixelBlock.width)*Math.round(f.height/t.pixelBlock.height)!==h.length||s.x<0||s.y<0||f.width<a.width||f.height<a.height?null:{extent:r,pixelBlock:J(h.map(d=>d.pixelBlock),f,{clipOffset:s,clipSize:a})}}function $(e,r,t,i,o,l){const{width:h,height:x}=t.block,{x:n,y:c}=t.offset,{width:p,height:s}=t.mosaic,f=function lt(e,r,t,i,o,l,h,x){return{xmin:o<=t*e?0:o<t*e+e?o-t*e:e,ymin:l<=i*r?0:l<i*r+r?l-i*r:r,xmax:o+h<=t*e?0:o+h<t*e+e?o+h-t*e:e,ymax:l+x<=i*r?0:l+x<i*r+r?l+x-i*r:r}}(h,x,i,o,n,c,p,s);let a=0,d=0;if(l){const u=l.hasGCSSShiftTransform?360:l.halfWorldWidth,w=h*l.resolutionX,y=l.startX+i*w,k=y+w;y<u&&k>u?d=l.rightPadding:y>=u&&(a=l.leftMargin-l.rightPadding,d=0)}if(f.xmax-=d,"number"!=typeof r)for(let u=f.ymin;u<f.ymax;u++){const w=(o*x+u-c)*p+(i*h-n)+a,y=u*h;for(let k=f.xmin;k<f.xmax;k++)e[w+k]=r[y+k]}else for(let u=f.ymin;u<f.ymax;u++){const w=(o*x+u-c)*p+(i*h-n)+a;for(let y=f.xmin;y<f.xmax;y++)e[w+y]=r}}function J(e,r,t={}){const{clipOffset:i,clipSize:o,alignmentInfo:l,blockWidths:h}=t;if(h)return function K(e,r,t){const i=e.find(a=>(0,S.pC)(a));if((0,S.Wi)(i))return null;const o=e.some(a=>!(0,S.pC)(a)||!!a.mask),{width:l,height:h}=r,x=o?new Uint8Array(l*h):null,{blockWidths:n}=t,c=[],p=i.getPlaneCount(),s=V.Z.getPixelArrayConstructor(i.pixelType);if(o)for(let a=0,d=0;a<e.length;d+=n[a],a++){const u=e[a];if(!L(u))continue;const w=u.mask;for(let y=0;y<h;y++)for(let k=0;k<n[a];k++)x[y*l+k+d]=null==w?255:w[y*u.width+k]}for(let a=0;a<p;a++){const d=new s(l*h);for(let u=0,w=0;u<e.length;w+=n[u],u++){const y=e[u];if(!L(y))continue;const k=y.pixels[a];if(null!=k)for(let T=0;T<h;T++)for(let A=0;A<n[u];A++)d[T*l+A+w]=k[T*y.width+A]}c.push(d)}const f=new V.Z({width:l,height:h,mask:x,pixels:c,pixelType:i.pixelType});return f.updateStatistics(),f}(e,r,{blockWidths:h});const x=e.find(b=>L(b));if((0,S.Wi)(x))return null;const n=o?o.width:r.width,c=o?o.height:r.height,p=x.width,s=x.height,f=r.width/p,a=r.height/s,d={offset:i||{x:0,y:0},mosaic:o||r,block:{width:p,height:s}},u=x.pixelType,w=V.Z.getPixelArrayConstructor(u),y=x.pixels.length,k=[];let T,A,W;for(let b=0;b<y;b++){A=new w(n*c);for(let I=0;I<a;I++)for(let B=0;B<f;B++){const O=e[I*f+B];L(O)&&(T=O.pixels[b],$(A,T,d,B,I,l))}k.push(A)}if(e.some(b=>(0,S.Wi)(b)||b.mask&&b.mask.length>0)){W=new Uint8Array(n*c);for(let b=0;b<a;b++)for(let I=0;I<f;I++){const B=e[b*f+I];$(W,((0,S.pC)(B)?B.mask:null)||(B?1:0),d,I,b,l)}}const j=new V.Z({width:n,height:c,pixels:k,pixelType:u,mask:W});return j.updateStatistics(),j}function rt(e,r,t){if(!L(e))return null;const{width:i,height:o}=e,l=r.x,h=r.y,x=t.width+l,n=t.height+h;if(l<0||h<0||x>i||n>o||0===l&&0===h&&x===i&&n===o)return e;e.mask||(e.mask=new Uint8Array(i*o));const c=e.mask;for(let p=0;p<o;p++){const s=p*i;for(let f=0;f<i;f++)c[s+f]=p<h||p>=n||f<l||f>=x?0:1}return e.updateStatistics(),e}function m(e){if(0===e.size)return 0;let r=0,t=-1,i=0;const o=e.keys();let l=o.next();for(;!l.done;)i=e.get(l.value),i>r&&(t=l.value,r=i),l=o.next();return t}function U(e,r,t){if(0===t)return;const i=e.get(r);1===i?e.delete(r):e.set(r,i-1)}function M(e,r,t){0!==t&&e.set(r,e.has(r)?e.get(r)+1:1)}function P(e,r,t){let{x:i,y:o}=r;const{width:l,height:h}=t;if(0===i&&0===o&&h===e.height&&l===e.width)return e;const{width:x,height:n}=e,c=Math.max(0,o),p=Math.max(0,i),s=Math.min(i+l,x),f=Math.min(o+h,n);if(s<0||f<0||!L(e))return null;i=Math.max(0,-i),o=Math.max(0,-o);const{pixels:a,mask:d}=e,u=l*h,w=a.length,y=[];for(let A=0;A<w;A++){const W=a[A],j=V.Z.createEmptyBand(e.pixelType,u);for(let b=c;b<f;b++){const I=b*x;let B=(b+o-c)*l+i;for(let O=p;O<s;O++)j[B++]=W[I+O]}y.push(j)}const k=new Uint8Array(u);for(let A=c;A<f;A++){const W=A*x;let j=(A+o-c)*l+i;for(let b=p;b<s;b++)k[j++]=d?d[W+b]:1}const T=new V.Z({width:t.width,height:t.height,pixelType:e.pixelType,pixels:y,mask:k});return T.updateStatistics(),T}function C(e,r=!0){if(!L(e))return null;const{pixels:t,width:i,height:o,mask:l,pixelType:h}=e,x=[],n=Math.round(i/2),c=Math.round(o/2),p=o-1,s=i-1;for(let a=0;a<t.length;a++){const d=t[a],u=V.Z.createEmptyBand(h,n*c);let w=0;for(let y=0;y<o;y+=2)for(let k=0;k<i;k+=2){const T=d[y*i+k];if(r){const A=k===s?T:d[y*i+k+1],W=y===p?T:d[y*i+k+i];u[w++]=(T+A+W+(k===s?W:y===p?A:d[y*i+k+i+1]))/4}else u[w++]=T}x.push(u)}let f=null;if(l){f=new Uint8Array(n*c);let a=0;for(let d=0;d<o;d+=2)for(let u=0;u<i;u+=2){const w=l[d*i+u];if(r){const y=u===s?w:l[d*i+u+1],k=d===p?w:l[d*i+u+i];f[a++]=w*y*k*(u===s?k:d===p?y:l[d*i+u+i+1])?1:0}else f[a++]=w}}return new V.Z({width:n,height:c,pixelType:h,pixels:x,mask:f})}function _(e,r,t){if(!L(e))return null;const{width:i,height:o}=r;let{width:l,height:h}=e;const x=new Map,n={x:0,y:0},c=null==t?1:1+t;let p=e;for(let s=0;s<c;s++){const f=Math.ceil(l/i),a=Math.ceil(h/o);for(let d=0;d<a;d++){n.y=d*o;for(let u=0;u<f;u++){n.x=u*i;const w=P(p,n,r);x.set(`${s}/${d}/${u}`,w)}}s<c-1&&(p=C(p)),l=Math.round(l/2),h=Math.round(h/2)}return x}function v(e,r,t,i,o=.5){const{width:l,height:h}=e,{width:x,height:n}=r,c=i.cols,p=i.rows,s=Math.ceil(x/c-.1/c),f=Math.ceil(n/p-.1/p);let a,d,u,w,y,k,T;const A=s*c,W=A*f*p,j=new Float32Array(W),b=new Float32Array(W),I=new Uint32Array(W),B=new Uint32Array(W);let O,Q,G=0;for(let N=0;N<f;N++)for(let z=0;z<s;z++){a=12*(N*s+z),d=t[a],u=t[a+1],w=t[a+2],y=t[a+3],k=t[a+4],T=t[a+5];for(let F=0;F<p;F++){G=(N*p+F)*A+z*c,Q=(F+.5)/p;for(let E=0;E<F;E++)O=(E+.5)/c,j[G+E]=(d*O+u*Q+w)*l-o,b[G+E]=(y*O+k*Q+T)*h-o,I[G+E]=Math.round(j[G+E]),B[G+E]=Math.round(b[G+E])}a+=6,d=t[a],u=t[a+1],w=t[a+2],y=t[a+3],k=t[a+4],T=t[a+5];for(let F=0;F<p;F++){G=(N*p+F)*A+z*c,Q=(F+.5)/p;for(let E=F;E<c;E++)O=(E+.5)/c,j[G+E]=(d*O+u*Q+w)*l-o,b[G+E]=(y*O+k*Q+T)*h-o,I[G+E]=Math.round(j[G+E]),B[G+E]=Math.round(b[G+E])}}return{offsets_x:j,offsets_y:b,offsets_xi:I,offsets_yi:B,gridWidth:A}}function D(e,r){const{coefficients:t,spacing:i}=r,{offsets_x:o,offsets_y:l,gridWidth:h}=v(e,e,t,{rows:i[0],cols:i[1]},.5),{width:x,height:n}=e,c=new Float32Array(x*n),p=180/Math.PI;for(let s=0;s<n;s++)for(let f=0;f<x;f++){const a=s*h+f,d=0===s?a:a-h,u=s===n-1?a:a+h,w=o[d]-o[u],y=l[u]-l[d];if(isNaN(w)||isNaN(y))c[s*x+f]=90;else{let k=Math.atan2(y,w)*p;k=(360+k)%360,c[s*x+f]=k}}return c}function R(e,r,t,i,o="nearest"){if(!L(e))return null;"majority"===o&&(e=function g(e){if(!L(e))return null;const r=e.clone(),{width:t,height:i,pixels:o,mask:l}=e,h=o[0],x=r.pixels[0];for(let n=2;n<i-1;n++){const c=new Map;for(let s=n-2;s<n+2;s++)for(let f=0;f<4;f++){const a=s*t+f;M(c,h[a],l?l[a]:1)}x[n*t]=m(c),x[n*t+1]=x[n*t+2]=x[n*t];let p=3;for(;p<t-1;p++){let s=(n-2)*t+p+1;M(c,h[s],l?l[s]:1),s=(n-1)*t+p+1,M(c,h[s],l?l[s]:1),s=n*t+p+1,M(c,h[s],l?l[s]:1),s=(n+1)*t+p+1,M(c,h[s],l?l[s]:1),s=(n-2)*t+p-3,U(c,h[s],l?l[s]:1),s=(n-1)*t+p-3,U(c,h[s],l?l[s]:1),s=n*t+p-3,U(c,h[s],l?l[s]:1),s=(n+1)*t+p-3,U(c,h[s],l?l[s]:1),x[n*t+p]=m(c)}x[n*t+p+1]=x[n*t+p]}for(let n=0;n<t;n++)x[n]=x[t+n]=x[2*t+n],x[(i-1)*t+n]=x[(i-2)*t+n];return r.updateStatistics(),r}(e));const{pixels:l,mask:h,pixelType:x}=e,n=e.width,c=e.height,p=V.Z.getPixelArrayConstructor(x),s=l.length,{width:f,height:a}=r;let d=!1;for(let B=0;B<t.length;B+=3)-1===t[B]&&-1===t[B+1]&&-1===t[B+2]&&(d=!0);const{offsets_x:u,offsets_y:w,offsets_xi:y,offsets_yi:k,gridWidth:T}=v({width:n,height:c},r,t,i,"majority"===o?0:.5);let A;const W=(B,O,Q)=>{const G=B instanceof Float32Array||B instanceof Float64Array?0:.5;for(let N=0;N<a;N++){A=N*T;for(let z=0;z<f;z++){if(u[A]<0||w[A]<0)B[N*f+z]=0;else if(Q)B[N*f+z]=O[y[A]+k[A]*n];else{const F=Math.floor(u[A]),E=Math.floor(w[A]),ot=Math.ceil(u[A]),H=Math.ceil(w[A]),Y=u[A]-F,at=w[A]-E;B[N*f+z]=!h||h[F+E*n]&&h[F+E*n]&&h[F+H*n]&&h[ot+H*n]?(1-at)*((1-Y)*O[F+E*n]+Y*O[ot+E*n])+at*((1-Y)*O[F+H*n]+Y*O[ot+H*n])+G:O[y[A]+k[A]*n]}A++}}},j=[];let b;for(let B=0;B<s;B++)b=new p(f*a),W(b,l[B],"nearest"===o||"majority"===o),j.push(b);const I=new V.Z({width:f,height:a,pixelType:x,pixels:j});if(h)I.mask=new Uint8Array(f*a),W(I.mask,h,!0);else if(d){I.mask=new Uint8Array(f*a);for(let B=0;B<f*a;B++)I.mask[B]=u[B]<0||w[B]<0?0:1}return I.updateStatistics(),I}}}]);